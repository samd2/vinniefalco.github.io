<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8">
    <title>Buffer Sequence Adaptors</title>
    <style type="text/css">
    body
    {
        font-size: 10pt;
        font-family: sans-serif;
    }
    code
    {
        display: block;
        white-space: pre;
        margin-top: -1.00em;
        margin-left: 2.0em;
    }
    p
    {
        text-align: justify
    }
    li {
        text-align: justify
    }
    ol.p
    {
        margin-left: -2.0em;
    }
    blockquote.note
    {
        background-color:#E0E0E0;
        padding-left: 15px;
        padding-right: 15px;
        padding-top: 1px;
        padding-bottom: 1px;
    }
    p.note
    {
        background-color:#E0E0E0;
        padding-left: 15px;
        padding-right: 15px;
        padding-top: 1px;
        padding-bottom: 1px;
    }
    ins { background-color: #CCFFCC; }
    del { background-color: #FFCCCC; }
    .insert { background-color: #CCFFCC; }
    address {text-align:right;}
    h1 {text-align:center;}
    span.comment {color:#C80000;}
    </style>
</head>
<body>
<pre>
Doc. no:  D0000R0
Audience: LEWG
Date:     2018-07-08
Reply-To: Vinnie Falco (<a href="mailto:vinnie.falco@gmail.com">vinnie.falco@gmail.com</a>)
</pre>
<hr>
<h1>Buffer Sequence Adaptors</h1>



<h2>Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
</ul>

<!----------------------------------------------------------------------------->

<h2 id="overview">1. Overview</h2>
<p>
This document proposes additional algorithms and types for working with
the buffer sequence concepts defined in [networking.ts].
</p>

<!----------------------------------------------------------------------------->

<h2 id="motivation">2. Motivation and Scope</h2>
<p>
[networking.ts] defines a buffer sequence as a bidirectional range of
non-owning references to individual contiguous memory regions. The adaptors
and types proposed in this paper allow for simply lazy transformations
of buffer sequences to achieve effects commonly used in implementations
which operate on buffers.
</p>

<h3 id="motivation.target">2.1 Target Audience</h3>
<p>
The algorithms and types provided here are aimed squarely at developers
working with [networking.ts].
</p>

<h3 id="motivation.reference">2.2 Reference Implementation</h3>
<p>
The Boost.Beast library, from portions of which this proposal is derived,
has been deployed in a number of production systems, such as internet-facing
HTTP servers, decentralized cryptocurrency networks, and finance applications.
The Boost.Beast library has been used on the following platforms:
</p>
<ul>
<li>Win32 using Visual Studio 14 and 15</li>
<li>Linux (newer kernels) using g++ 4.8 or later</li>
<li>Mac OS X 10.4 using clang 3.6 or later</li>
</ul>

<h3 id="motivation.related">2.3 Related Work</h3>
<p>
The interfaces used for transacting with buffer sequences are based on
idioms established in [networking.ts].
library.
</p>

<!----------------------------------------------------------------------------->

<h2 id="impact">3. Impact On the Standard</h2>
<p>
This is a pure library proposal. It does not add any new language features,
nor does it alter any existing standard library headers. This library can be
implemented using compilers that conform to the C++17 standard. However, the
library also requires [networking.ts].
</p>

<!----------------------------------------------------------------------------->

<h2 id="design">4. Design Decisions</h2>
<p>
The prefix <tt>buffers_</tt> was chosen because buffer sequences can contain
multiple memory regions. This distinguishes the algorithms from those functions
which operate on types meeting the requirements of <em>DynamicBuffer</em>, which
use the prefix <tt>buffer_</tt> (these algorithms are present in Boost.Beast but
not proposed here).
</p>
<p>
The types <tt>buffers_cat_view</tt> and <tt>buffers_prefix_view</tt> are made
public so that callers can build abstractions which refer to the type.
</p>

<!----------------------------------------------------------------------------->

<h2 id="wording">5. Proposed Wording (informative)</h2>

<p>Exact wording to be determined after [networking.ts] is merged</p>

<h3>5.1 Definitions</h3>
<ol>
<li><p>The concepts <em>ConstBufferSequence</em> and <em>MutableBufferSequence</em>
    are adopted from [networking.ts] as-is.</p></li>
<li><p>A type satisfies <em>BufferSequence</em> if it satisfies
    <em>MutableBufferSequence</em> or <em>ConstBufferSequence</em></p></li>
<li><p>The types <tt>const_buffer</tt> and <tt>mutable_buffer</tt> are
    adopted from [networking.ts] as-is.</p></li>
<li><p>Define <tt><em>BUFFER_TYPE</em>(TN...)</tt> as follows:</p>
    <ul>
    <li>The type <tt>mutable_buffer</tt> if every type in <tt>TN</tt>
    meets the requirements of <em>MutableBufferSequence</em>, otherwise:</li>
    <li>The type <tt>const_buffer</tt>.</li>
    </ul>
    <p class=note>[Note] possible implementation
        <code>
template &lt;class... TN&gt;
using BUFFER_TYPE = conditional_t&lt;
    (... &amp;&amp; is_mutable_buffer_sequence&lt;TN&gt;::value),
        mutable_buffer, const_buffer&gt;;
</code>
    </p>
    </li>

</ol>

<h3>5.2 Header <tt>&lt;experimental/buffer&gt;</tt> additions</h3>
<code>
namespace std {
namespace experimental {
namespace net {

template &lt;class... BN&gt;
class buffers_cat_view;

template &lt;class BS&gt;
class buffers_prefix_view;

template &lt;class BS&gt;
class buffers_suffix;

template &lt;class... BN&gt;
buffers_cat_view &lt;BN...&gt;
buffers_cat(BN const&amp;... buffers);

template &lt;class BS&gt;
buffers_front (BS const&amp; buffers);

const_buffer buffers_prefix (size_t size, const_buffer buffer);
mutable_buffer buffers_prefix (size_t size, mutable_buffer buffer);

template &lt;class BS&gt;
buffers_prefix_view &lt;BS&gt;
buffers_prefix (size_t size, BS const&amp; buffers);

} // net
} // experimental
} // std
</code>

<!----------------------------------------------------------------------------->

<h4>5.3 Class template <tt>buffers_cat_view</tt></h4>
<p>This class represents the concatenation of a variable number of
    buffer sequences of possibly dissimilar types.</p>
<code>
namespace std {
namespace experimental {
namespace net {

template &lt;class... BN&gt;
class buffers_cat_view
{
    tuple &lt;BN...&gt; bn_; // <em>exposition only</em>

public:
    using value_type = <em>BUFFER_TYPE(</em>BN...);

    using const_iterator = <em>implementation-defined</em>;

    explicit buffers_cat_view (BN const&amp;... buffers);

    buffers_cat_view (buffers_cat_view const&amp; other);

    const_iterator begin() const;
    const_iterator end() const;
};

} // net
} // experimental
} // std
</code>
<ol>
<li><p>Class template <tt>buffers_cat_view</tt> satisfies <em>ConstBufferSequence</em>.
    If <tt>value type</tt> is <tt>mutable_buffer</tt>, then <tt>buffers_cat_view</tt>
    also satisfies <em>MutableBufferSequence</em>.</p></li>
</ol>

<dl>
<dt><code>template &lt;class... BN&gt; class buffers_cat_view</code></dt>
<dd><p><em>Requires:</em> <tt>sizeof...(BN) &gt; 0</tt> and
    <tt>is_const_buffer_sequence&lt;BN&gt;::value</tt> is true
    for all <tt>BN</tt>.</p></dd>

<dt><code>const_iterator</code></dt>
<dd><p><em>Requires:</em> Meets the requirements of <em>MutableBufferSequence</em>
    if <tt>value_type</tt> is <tt>mutable_buffer</tt>, otherwise meets the
    requirements of <em>ConstBufferSequence</em>.</p></dd>

<dt><code>explicit buffers_cat_view (BN const&amp;... buffers)</code></dt>
<dd><p><em>Requires:</em>
    </p></dd>

<dt><code>buffers_cat_view (buffers_cat_view const&amp; other)</code></dt>
<dd><p><em>Effects:</em> Constructs a copy of <tt>other</tt>. The newly
    constructed object will contain a copy of each buffer sequence contained
    in <tt>other</tt>.</p></dd>

<dt><code>const_iterator begin() const</code></dt>
<dd><p><em>Returns:</em> An iterator to first element of the buffer sequence.</p></dd>

<dt><code>const_iterator end() const</code></dt>
<dd><p><em>Returns:</em> An iterator to one past-the-end of the buffer sequence.</p></dd>

<dt><code>template &lt;class... BN&gt;
buffers_cat_view &lt;BN...&gt;
buffers_cat(BN const&amp;... buffers)</code></dt>
<dd><p><em>Requires:</em> <tt>sizeof...(BN) &gt; 0</tt> and
    <tt>is_const_buffer_sequence&lt;BN&gt;::value</tt> is true
    for all <tt>BN</tt>.</p>
    <p><em>Returns:</em> <tt>buffers_cat_view&lt;BN&gt;(buffers)</tt>.</p></dd>
</dl>

<!----------------------------------------------------------------------------->

<h4>5.4 Class template <tt>buffers_prefix_view</tt></h4>
<code>
template &lt;class BS&gt;
class buffers_prefix_view
{
    BS bs_; // <em>exposition only</em>

public:
    using value_type = <em>implementation-defined</em>;
    using const_iterator = <em>implementation-defined</em>;

    buffers_prefix_view (size_t size, BS const& buffers);

    template &lt;class... Args&gt;
    buffers_prefix_view (size_t size, in_place_t, Args&amp;&amp;... args);

    buffers_prefix_view (buffers_prefix_view const&amp;);

    const_iterator begin() const;
    const_iterator end() const;
};
</code>
<ol>
<li>Class template <tt>buffers_prefix_view</tt> satisfies either the
    <em>ConstBufferSequence</em> or the <em>MutableBufferSequence</em> requirements.</li>
</ol>

<!----------------------------------------------------------------------------->

<h4>5.5 Class <tt>buffers_suffix</tt></h4>
<code>
template &lt;class BS&gt;
class buffers_suffix;
</code>

<!----------------------------------------------------------------------------->

<h4>5.6 Function <tt>buffers_cat</tt></h4>
<code>
template &lt;class... BN&gt;
buffers_cat_view &lt;BN...&gt;
buffers_cat(BN const&amp;... buffers);
</code>
<ol>
<li><p><em>Requires:</em> <tt>sizeof...(BN) &gt; 0</tt> and
    <tt>is_const_buffer_sequence&lt;BN&gt;::value</tt> is true
    for all <tt>BN</tt>.</p></li>
<li><p><em>Returns:</em> <tt>buffers_cat_view&lt;BN&gt;(buffers)</tt>.</p></li>
</ol>

<h4>5.7 Function <tt>buffers_prefix</tt></h4>
<code>
const_buffer buffers_prefix (size_t size, const_buffer buffer);
mutable_buffer buffers_prefix (size_t size, mutable_buffer buffer);

template &lt;class BS&gt;
buffers_prefix_view &lt;BS&gt;
buffers_prefix (size_t size, BS const&amp; buffers);
</code>

<!----------------------------------------------------------------------------->

<h4>5.8 Function <tt>buffers_front</tt></h4>
<code>template &lt;class BS&gt;
buffers_front (BS const&amp; buffers);
</code>
<ol>
<li><tt>BS</tt> satisfies the requirement of 
</body>
