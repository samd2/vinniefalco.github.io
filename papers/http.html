<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8">
    <title>Introducing std::net::http</title>
    <style type="text/css">
    p {text-align:justify}
    li {text-align:justify}
    blockquote.note
    {
        background-color:#E0E0E0;
        padding-left: 15px;
        padding-right: 15px;
        padding-top: 1px;
        padding-bottom: 1px;
    }
    p.note
    {
        background-color:#E0E0E0;
        padding-left: 15px;
        padding-right: 15px;
        padding-top: 1px;
        padding-bottom: 1px;
    }
    ins { background-color: #CCFFCC; }
    del { background-color: #FFCCCC; }
    .insert { background-color: #CCFFCC; }
    address {text-align:right;}
    h1 {text-align:center;}
    span.comment {color:#C80000;}
    code {white-space:pre;}
    </style>
</head>
<body>
<pre>
Doc. no:  D0000R0
Audience: LEWG
Date:     2018-07-07
Reply-To: Vinnie Falco (<a href="mailto:vinnie.falco@gmail.com">vinnie.falco@gmail.com</a>)
</pre>
<hr>
<h1>Introducing <tt>std::net::http</tt></h1>



<h2>Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
</ul>

<h2 id="overview">Overview</h2>
<p>
This document proposes an HTTP protocol library for C++. The library is
aimed at providing low-level abstractions only. The benefit is that HTTP
programs built with this library will be easier and faster to implement,
understand, and maintain, because the library takes care of the protocol
details.
</p>



<h2 id="motivation">Motivation and Scope</h2>



<h3 id="motivation.scope">Scope</h3>
<p>
Problem areas addressed by this proposal include:
<ul>
<li>Buffer-oriented HTTP/1 parsing and serialization.</li>
<li>Modeling of HTTP/1 and HTTP/2 messages as first-class objects.</li>
<li>Synchronous and asynchronous stream algorithms for HTTP/1 parsing and serialization.</li>
<li>Automatic management of the Connection, Content-Length,
    Transfer-Encoding, and Upgrade HTTP field values.</li>
</ul>
</p>
<p>
Features that are considered outside the scope of this proposal include:
<ul>
<li>HTTP/0.9 serialization and parsing.</li>
<li>HTTP/2 serialization and parsing.</li>
<li>Tolerant parsing of HTTP/1.</li>
<li>General processing of HTTP field values.</li>
<li>Parsing of HTTP variations (e.g. "ICY 200 OK").</li>
<li>SSL/TLS certificate verification and management.</li>
<li>Connection establishment, closure, and domain name resolution.</li>
<li>Interpreting the semantics of HTTP message bodies.</li>
<li>request-target URI parsing.</li>
</ul>
</p>


<h3 id="motivation.target">Target Audience</h3>
<p>
The bulk of the library interface is intended for use by developers with
an understanding of Networking TS concepts, as well as a good grasp of
HTTP protocol semantics. Most end users will likely not interact with
the library directly; instead, this library will be used to build higher
level abstractions such as full-featured HTTP clients or HTTP servers.
This document refers to abstractions built on top of this library as
<em>HTTP middleware</em> (or just <em>middleware</em>).
</p>


<h3 id="motivation.reference">Reference Implementation</h3>
<p>
The Boost.Beast library, from which this proposal is derived, has been
deployed in a number of production systems, such as internet-facing HTTP
servers, decentralized cryptocurrency networks, and finance applications.
The Boost.Beast  library has been used on the following platforms:
</p>
<ul>
<li>Win32 using Visual Studio 14 and 15</li>
<li>Linux (newer kernels) using g++ 4.8 or later</li>
<li>Mac OS X 10.4 using clang 3.6 or later</li>
</ul>



<h3 id="motivation.related">Related Work</h3>
<p>
The interfaces used for transacting with streams are based on idioms
established by the Networking TS. In particular this library adopts the
Universal Asynchronous Model defined by the TS.
</p>




<h2 id="impact">Impact On the Standard</h2>
<p>
This is a pure library proposal. It does not add any new language features,
nor does it alter any existing standard library headers. This library can be
implemented using compilers that conform to the C++17 standard (or later).
However, this library also requires the library features offered in
Networking TS.
</p>



<h2 id="design">Design Decisions</h2>
<p>
The overarching design principle of this library is <em>"Don't make odd
choices on behalf of the user."</em> Important decisions such as when and
how to allocate memory are left to the caller. Customization points allow
all the "interesting" behaviors to be user-defined. It is important to
recognize that this library is <em>low-level</em>. It is not a complete
HTTP client nor does it provide a complete HTTP server. However, those
things can be built with the library. Specifically, this library provides
the following:
</p>
<ul>
<li>A flexible container for holding HTTP/1 and HTTP/2 messages</li>
<li>Read algorithms: deserialize HTTP/1 messages from a readable stream</li>
<li>Write algorithms: serialize HTTP/1 messages to a writable stream</li>
<li>Parsing: parse HTTP/1 messages from caller-provided buffers</li>
<li>Serialization: Serialize HTTP/1 messages to caller-provided buffers</li>
</ul>
<p>
Most importantly, this library defines a universal class template for holding
any type of HTTP message, including HTTP/1 and HTTP/2. This allows authors
to write functional algorithms which operate only on messages, independent
of streams or networking, with the guarantee that these algorithms will
interoperate seamlessly.
</p>

<h3 id="design.netts">Networking TS</h3>
<p>
All stream algorithms use interfaces similar or identical to those found in
the Networking TS. The advantage is that skill acquired at operating the TS
will translate directly into skill with using HTTP stream algorithms.
To prevent duplication of functionality, the library only provides
algorithms which are strictly part of the low-level HTTP protocol.
Other operations, such as perfoming DNS lookups or making outgoing
TCP/IP connections, are left to the Networking TS.
</p>

<h3 id="design.transport">Transport Independence</h3>
<p>
Stream algorithms are expressed as function templates which operate on
stream concepts. This allows any form of transport to be used, including
TCP/IP sockets but also including properly configured SSL or TLS streams.
Unconventional transports such as interprocess communication may also be
used, if an implementation exists or can be written to meet the concept
requirements.
</p>



<h2 id="wording">Proposed Text for the Standard</h2>

<h3>Header <tt>&lt;net/http/message&gt;</tt> synopsis</h3>

<p>This file provides declarations related to the HTTP message container</p>
<pre><tt>
namespace std {
namespace net {
namespace http {

enum class field : unsigned short
{
    unknown = 0,

    a_im,
    accept,
    accept_additions,
    accept_charset,
    accept_datetime,
    accept_encoding,
    accept_features,
    accept_language,
    accept_patch,
    accept_post,
    accept_ranges,
    access_control,
    access_control_allow_credentials,
    access_control_allow_headers,
    access_control_allow_methods,
    access_control_allow_origin,
    access_control_expose_headers,
    access_control_max_age,
    access_control_request_headers,
    access_control_request_method,
    age,
    allow,
    alpn,
    also_control,
    alt_svc,
    alt_used,
    alternate_recipient,
    alternates,
    apparently_to,
    apply_to_redirect_ref,
    approved,
    archive,
    archived_at,
    article_names,
    article_updates,
    authentication_control,
    authentication_info,
    authentication_results,
    authorization,
    auto_submitted,
    autoforwarded,
    autosubmitted,
    base,
    bcc,
    body,
    c_ext,
    c_man,
    c_opt,
    c_pep,
    c_pep_info,
    cache_control,
    caldav_timezones,
    cancel_key,
    cancel_lock,
    cc,
    close,
    comments,
    compliance,
    connection,
    content_alternative,
    content_base,
    content_description,
    content_disposition,
    content_duration,
    content_encoding,
    content_features,
    content_id,
    content_identifier,
    content_language,
    content_length,
    content_location,
    content_md5,
    content_range,
    content_return,
    content_script_type,
    content_style_type,
    content_transfer_encoding,
    content_type,
    content_version,
    control,
    conversion,
    conversion_with_loss,
    cookie,
    cookie2,
    cost,
    dasl,
    date,
    date_received,
    dav,
    default_style,
    deferred_delivery,
    delivery_date,
    delta_base,
    depth,
    derived_from,
    destination,
    differential_id,
    digest,
    discarded_x400_ipms_extensions,
    discarded_x400_mts_extensions,
    disclose_recipients,
    disposition_notification_options,
    disposition_notification_to,
    distribution,
    dkim_signature,
    dl_expansion_history,
    downgraded_bcc,
    downgraded_cc,
    downgraded_disposition_notification_to,
    downgraded_final_recipient,
    downgraded_from,
    downgraded_in_reply_to,
    downgraded_mail_from,
    downgraded_message_id,
    downgraded_original_recipient,
    downgraded_rcpt_to,
    downgraded_references,
    downgraded_reply_to,
    downgraded_resent_bcc,
    downgraded_resent_cc,
    downgraded_resent_from,
    downgraded_resent_reply_to,
    downgraded_resent_sender,
    downgraded_resent_to,
    downgraded_return_path,
    downgraded_sender,
    downgraded_to,
    ediint_features,
    eesst_version,
    encoding,
    encrypted,
    errors_to,
    etag,
    expect,
    expires,
    expiry_date,
    ext,
    followup_to,
    forwarded,
    from,
    generate_delivery_report,
    getprofile,
    hobareg,
    host,
    http2_settings,
    if_,
    if_match,
    if_modified_since,
    if_none_match,
    if_range,
    if_schedule_tag_match,
    if_unmodified_since,
    im,
    importance,
    in_reply_to,
    incomplete_copy,
    injection_date,
    injection_info,
    jabber_id,
    keep_alive,
    keywords,
    label,
    language,
    last_modified,
    latest_delivery_time,
    lines,
    link,
    list_archive,
    list_help,
    list_id,
    list_owner,
    list_post,
    list_subscribe,
    list_unsubscribe,
    list_unsubscribe_post,
    location,
    lock_token,
    man,
    max_forwards,
    memento_datetime,
    message_context,
    message_id,
    message_type,
    meter,
    method_check,
    method_check_expires,
    mime_version,
    mmhs_acp127_message_identifier,
    mmhs_authorizing_users,
    mmhs_codress_message_indicator,
    mmhs_copy_precedence,
    mmhs_exempted_address,
    mmhs_extended_authorisation_info,
    mmhs_handling_instructions,
    mmhs_message_instructions,
    mmhs_message_type,
    mmhs_originator_plad,
    mmhs_originator_reference,
    mmhs_other_recipients_indicator_cc,
    mmhs_other_recipients_indicator_to,
    mmhs_primary_precedence,
    mmhs_subject_indicator_codes,
    mt_priority,
    negotiate,
    newsgroups,
    nntp_posting_date,
    nntp_posting_host,
    non_compliance,
    obsoletes,
    opt,
    optional,
    optional_www_authenticate,
    ordering_type,
    organization,
    origin,
    original_encoded_information_types,
    original_from,
    original_message_id,
    original_recipient,
    original_sender,
    original_subject,
    originator_return_address,
    overwrite,
    p3p,
    path,
    pep,
    pep_info,
    pics_label,
    position,
    posting_version,
    pragma,
    prefer,
    preference_applied,
    prevent_nondelivery_report,
    priority,
    privicon,
    profileobject,
    protocol,
    protocol_info,
    protocol_query,
    protocol_request,
    proxy_authenticate,
    proxy_authentication_info,
    proxy_authorization,
    proxy_connection,
    proxy_features,
    proxy_instruction,
    public_,
    public_key_pins,
    public_key_pins_report_only,
    range,
    received,
    received_spf,
    redirect_ref,
    references,
    referer,
    referer_root,
    relay_version,
    reply_by,
    reply_to,
    require_recipient_valid_since,
    resent_bcc,
    resent_cc,
    resent_date,
    resent_from,
    resent_message_id,
    resent_reply_to,
    resent_sender,
    resent_to,
    resolution_hint,
    resolver_location,
    retry_after,
    return_path,
    safe,
    schedule_reply,
    schedule_tag,
    sec_websocket_accept,
    sec_websocket_extensions,
    sec_websocket_key,
    sec_websocket_protocol,
    sec_websocket_version,
    security_scheme,
    see_also,
    sender,
    sensitivity,
    server,
    set_cookie,
    set_cookie2,
    setprofile,
    sio_label,
    sio_label_history,
    slug,
    soapaction,
    solicitation,
    status_uri,
    strict_transport_security,
    subject,
    subok,
    subst,
    summary,
    supersedes,
    surrogate_capability,
    surrogate_control,
    tcn,
    te,
    timeout,
    title,
    to,
    topic,
    trailer,
    transfer_encoding,
    ttl,
    ua_color,
    ua_media,
    ua_pixels,
    ua_resolution,
    ua_windowpixels,
    upgrade,
    urgency,
    uri,
    user_agent,
    variant_vary,
    vary,
    vbr_info,
    version,
    via,
    want_digest,
    warning,
    www_authenticate,
    x_archived_at,
    x_device_accept,
    x_device_accept_charset,
    x_device_accept_encoding,
    x_device_accept_language,
    x_device_user_agent,
    x_frame_options,
    x_mittente,
    x_pgp_sig,
    x_ricevuta,
    x_riferimento_message_id,
    x_tiporicevuta,
    x_trasporto,
    x_verificasicurezza,
    x400_content_identifier,
    x400_content_return,
    x400_content_type,
    x400_mts_identifier,
    x400_originator,
    x400_received,
    x400_recipients,
    x400_trace,
    xref,
};

enum class status : unsigned
{
    unknown = 0,

    continue_                           = 100,
    switching_protocols                 = 101,
    processing                          = 102,

    ok                                  = 200,
    created                             = 201,
    accepted                            = 202,
    non_authoritative_information       = 203,
    no_content                          = 204,
    reset_content                       = 205,
    partial_content                     = 206,
    multi_status                        = 207,
    already_reported                    = 208,
    im_used                             = 226,

    multiple_choices                    = 300,
    moved_permanently                   = 301,
    found                               = 302,
    see_other                           = 303,
    not_modified                        = 304,
    use_proxy                           = 305,
    temporary_redirect                  = 307,
    permanent_redirect                  = 308,

    bad_request                         = 400,
    unauthorized                        = 401,
    payment_required                    = 402,
    forbidden                           = 403,
    not_found                           = 404,
    method_not_allowed                  = 405,
    not_acceptable                      = 406,
    proxy_authentication_required       = 407,
    request_timeout                     = 408,
    conflict                            = 409,
    gone                                = 410,
    length_required                     = 411,
    precondition_failed                 = 412,
    payload_too_large                   = 413,
    uri_too_long                        = 414,
    unsupported_media_type              = 415,
    range_not_satisfiable               = 416,
    expectation_failed                  = 417,
    misdirected_request                 = 421,
    unprocessable_entity                = 422,
    locked                              = 423,
    failed_dependency                   = 424,
    upgrade_required                    = 426,
    precondition_required               = 428,
    too_many_requests                   = 429,
    request_header_fields_too_large     = 431,
    connection_closed_without_response  = 444,
    unavailable_for_legal_reasons       = 451,
    client_closed_request               = 499,

    internal_server_error               = 500,
    not_implemented                     = 501,
    bad_gateway                         = 502,
    service_unavailable                 = 503,
    gateway_timeout                     = 504,
    http_version_not_supported          = 505,
    variant_also_negotiates             = 506,
    insufficient_storage                = 507,
    loop_detected                       = 508,
    not_extended                        = 510,
    network_authentication_required     = 511,
    network_connect_timeout_error       = 599
};

enum class status_class : unsigned
{
    unknown             = 0,
    informational       = 1,
    successful          = 2,
    redirection         = 3,
    client_error        = 4,
    server_error        = 5,
};

enum class verb
{
    unknown = 0,

    delete_,
    get,
    head,
    post,
    put,
    connect,
    options,
    trace,

    // WebDAV
    copy,
    lock,
    mkcol,
    move,
    propfind,
    proppatch,
    search,
    unlock,
    bind,
    rebind,
    unbind,
    acl,

    // Subversion
    report,
    mkactivity,
    checkout,
    merge,

    // UPnP
    msearch,
    notify,
    subscribe,
    unsubscribe,

    // RFC-5789
    patch, purge,

    // CalDAV
    mkcalendar,

    // RFC-2068, section 19.6.1.2
    link,
    unlink
};

string_view field_to_string(field f);

field string_to_field(string_view s);

std::ostream& operator<<(std::ostream& os, field f);

status int_to_status(unsigned v);

status_class to_status_class(unsigned v);

status_class to_status_class(status v);

string_view obsolete_reason(status v);

std::ostream& operator<<(std::ostream& os, status s);

verb string_to_verb(string_view s);

string_view verb_to_string(verb v);

std::ostream& operator<<(std::ostream& os, verb v);


class basic_fields
#if ! BOOST_BEAST_DOXYGEN
    : private beast::detail::empty_base_optimization<Allocator>
#endif
{
    // Fancy pointers are not supported
    static_assert(std::is_pointer<typename
        std::allocator_traits<Allocator>::pointer>::value,
        "Allocator must use regular pointers");

    friend class fields_test; // for `header`

    static std::size_t constexpr max_static_buffer = 4096;

    using off_t = std::uint16_t;

public:
    /// The type of allocator used.
    using allocator_type = Allocator;

    /// The type of element used to represent a field 
    class value_type
    {
        friend class basic_fields;

        boost::asio::const_buffer
        buffer() const;

        value_type(field name,
            string_view sname, string_view value);

        boost::intrusive::list_member_hook<
            boost::intrusive::link_mode<
                boost::intrusive::normal_link>>
                    list_hook_;
        boost::intrusive::set_member_hook<
            boost::intrusive::link_mode<
                boost::intrusive::normal_link>>
                    set_hook_;
        off_t off_;
        off_t len_;
        field f_;

    public:
        /// Constructor (deleted)
        value_type(value_type const&) = delete;

        /// Assignment (deleted)
        value_type& operator=(value_type const&) = delete;

        /// Returns the field enum, which can be @ref field::unknown
        field
        name() const;

        /// Returns the field name as a string
        string_view const
        name_string() const;

        /// Returns the value of the field
        string_view const
        value() const;
    };

    /** A strictly less predicate for comparing keys, using a case-insensitive comparison.

        The case-comparison operation is defined only for low-ASCII characters.
    */
    struct key_compare : beast::iless
    {
        /// Returns `true` if lhs is less than rhs using a strict ordering
        template<class String>
        bool
        operator()(
            String const& lhs,
            value_type const& rhs) const noexcept
        {
            if(lhs.size() < rhs.name_string().size())
                return true;
            if(lhs.size() > rhs.name_string().size())
                return false;
            return iless::operator()(lhs, rhs.name_string());
        }

        /// Returns `true` if lhs is less than rhs using a strict ordering
        template<class String>
        bool
        operator()(
            value_type const& lhs,
            String const& rhs) const noexcept
        {
            if(lhs.name_string().size() < rhs.size())
                return true;
            if(lhs.name_string().size() > rhs.size())
                return false;
            return iless::operator()(lhs.name_string(), rhs);
        }

        /// Returns `true` if lhs is less than rhs using a strict ordering
        bool
        operator()(
            value_type const& lhs,
            value_type const& rhs) const noexcept
        {
            if(lhs.name_string().size() < rhs.name_string().size())
                return true;
            if(lhs.name_string().size() > rhs.name_string().size())
                return false;
            return iless::operator()(lhs.name_string(), rhs.name_string());
        }
    };

    /// The algorithm used to serialize the header
#if BOOST_BEAST_DOXYGEN
    using writer = implementation_defined;
#else
    class writer;
#endif

private:
    using list_t = typename boost::intrusive::make_list<
        value_type, boost::intrusive::member_hook<
            value_type, boost::intrusive::list_member_hook<
                boost::intrusive::link_mode<
                    boost::intrusive::normal_link>>,
                        &value_type::list_hook_>,
                            boost::intrusive::constant_time_size<
                                false>>::type;

    using set_t = typename boost::intrusive::make_multiset<
        value_type, boost::intrusive::member_hook<value_type,
            boost::intrusive::set_member_hook<
                boost::intrusive::link_mode<
                    boost::intrusive::normal_link>>,
                        &value_type::set_hook_>,
                            boost::intrusive::constant_time_size<true>,
                                boost::intrusive::compare<key_compare>>::type;

    using align_type = typename
        boost::type_with_alignment<alignof(value_type)>::type;

    using rebind_type = typename
        beast::detail::allocator_traits<Allocator>::
            template rebind_alloc<align_type>;

    using alloc_traits =
        beast::detail::allocator_traits<rebind_type>;

    using size_type = typename
        beast::detail::allocator_traits<Allocator>::size_type;


public:
    /// Destructor
    ~basic_fields();

    /// Constructor.
    basic_fields() = default;

    /** Constructor.

        @param alloc The allocator to use.
    */
    explicit
    basic_fields(Allocator const& alloc) noexcept;

    /** Move constructor.

        The state of the moved-from object is
        as if constructed using the same allocator.
    */
    basic_fields(basic_fields&&) noexcept;

    /** Move constructor.

        The state of the moved-from object is
        as if constructed using the same allocator.

        @param alloc The allocator to use.
    */
    basic_fields(basic_fields&&, Allocator const& alloc);

    /// Copy constructor.
    basic_fields(basic_fields const&);

    /** Copy constructor.

        @param alloc The allocator to use.
    */
    basic_fields(basic_fields const&, Allocator const& alloc);

    /// Copy constructor.
    template<class OtherAlloc>
    basic_fields(basic_fields<OtherAlloc> const&);

    /** Copy constructor.

        @param alloc The allocator to use.
    */
    template<class OtherAlloc>
    basic_fields(basic_fields<OtherAlloc> const&,
        Allocator const& alloc);

    /** Move assignment.

        The state of the moved-from object is
        as if constructed using the same allocator.
    */
    basic_fields& operator=(basic_fields&&) noexcept(
        alloc_traits::propagate_on_container_move_assignment::value);

    /// Copy assignment.
    basic_fields& operator=(basic_fields const&);

    /// Copy assignment.
    template<class OtherAlloc>
    basic_fields& operator=(basic_fields<OtherAlloc> const&);

public:
    /// A constant iterator to the field sequence.
#if BOOST_BEAST_DOXYGEN
    using const_iterator = implementation_defined;
#else
    using const_iterator = typename list_t::const_iterator;
#endif

    /// A constant iterator to the field sequence.
    using iterator = const_iterator;

    /// Return a copy of the allocator associated with the container.
    allocator_type
    get_allocator() const
    {
        return this->member();
    }

    //--------------------------------------------------------------------------
    //
    // Element access
    //
    //--------------------------------------------------------------------------

    /** Returns the value for a field, or throws an exception.

        If more than one field with the specified name exists, the
        first field defined by insertion order is returned.

        @param name The name of the field.

        @return The field value.

        @throws std::out_of_range if the field is not found.
    */
    string_view const
    at(field name) const;

    /** Returns the value for a field, or throws an exception.

        If more than one field with the specified name exists, the
        first field defined by insertion order is returned.

        @param name The name of the field.

        @return The field value.

        @throws std::out_of_range if the field is not found.
    */
    string_view const
    at(string_view name) const;

    /** Returns the value for a field, or `""` if it does not exist.

        If more than one field with the specified name exists, the
        first field defined by insertion order is returned.

        @param name The name of the field.
    */
    string_view const
    operator[](field name) const;

    /** Returns the value for a case-insensitive matching header, or `""` if it does not exist.

        If more than one field with the specified name exists, the
        first field defined by insertion order is returned.

        @param name The name of the field.
    */
    string_view const
    operator[](string_view name) const;

    //--------------------------------------------------------------------------
    //
    // Iterators
    //
    //--------------------------------------------------------------------------

    /// Return a const iterator to the beginning of the field sequence.
    const_iterator
    begin() const
    {
        return list_.cbegin();
    }

    /// Return a const iterator to the end of the field sequence.
    const_iterator
    end() const
    {
        return list_.cend();
    }

    /// Return a const iterator to the beginning of the field sequence.
    const_iterator
    cbegin() const
    {
        return list_.cbegin();
    }

    /// Return a const iterator to the end of the field sequence.
    const_iterator
    cend() const
    {
        return list_.cend();
    }

    //--------------------------------------------------------------------------
    //
    // Capacity
    //
    //--------------------------------------------------------------------------

private:
    // VFALCO Since the header and message derive from Fields,
    //        what does the expression m.empty() mean? Its confusing.
    bool
    empty() const
    {
        return list_.empty();
    }
public:

    //--------------------------------------------------------------------------
    //
    // Modifiers
    //
    //--------------------------------------------------------------------------

    /** Remove all fields from the container

        All references, pointers, or iterators referring to contained
        elements are invalidated. All past-the-end iterators are also
        invalidated.

        @par Postconditions:
        @code
            std::distance(this->begin(), this->end()) == 0
        @endcode
    */
    void
    clear();

    /** Insert a field.

        If one or more fields with the same name already exist,
        the new field will be inserted after the last field with
        the matching name, in serialization order.

        @param name The field name.

        @param value The value of the field, as a @ref string_param
    */
    void
    insert(field name, string_param const& value);

    /** Insert a field.

        If one or more fields with the same name already exist,
        the new field will be inserted after the last field with
        the matching name, in serialization order.

        @param name The field name.

        @param value The value of the field, as a @ref string_param
    */
    void
    insert(string_view name, string_param const& value);

    /** Insert a field.

        If one or more fields with the same name already exist,
        the new field will be inserted after the last field with
        the matching name, in serialization order.

        @param name The field name.

        @param name_string The literal text corresponding to the
        field name. If `name != field::unknown`, then this value
        must be equal to `to_string(name)` using a case-insensitive
        comparison, otherwise the behavior is undefined.

        @param value The value of the field, as a @ref string_param
    */
    void insert (field name, string_view name_string, string_view value);
    void set (field name, string_view value);
    void set (string_view name, string_view value);
    const_iterator erase (const_iterator pos);
    size_t erase (field name);
    size_t erase (string_view name);
    void swap (basic_fields& other);
    template&lt;class Alloc&gt;
    friend void swap (basic_fields&lt;Alloc&gt;& lhs, basic_fields&lt;Alloc&gt;& rhs);

    // Lookup

    size_t count (field name) const;
    size_t count (string_view name) const;
    const_iterator find (field name) const;
    const_iterator find (string_view name) const;
    pair&lt;const_iterator, const_iterator&gt; equal_range (field name) const;
    pair&lt;const_iterator, const_iterator&gt; equal_range (string_view name) const;

    // Observers

    key_compare key_comp() const;

protected:
    string_view get_method_impl () const;
    string_view get_target_impl () const;
    string_view get_reason_impl () const;
    bool get_chunked_impl () const;
    bool get_keep_alive_impl (unsigned version) const;
    bool has_content_length_impl () const;

    void set_method_impl (string_view s);
    void set_target_impl (string_view s);
    void set_reason_impl (string_view s);
    void set_chunked_impl (bool value);
    void set_content_length_impl (optional&lt;uint64_t&gt; const& value);
    void set_keep_alive_impl (unsigned version, bool keep_alive);
};

using fields = basic_fields&lt;allocator&lt;char&gt;&gt;;

} // http
} // net
} // std

</tt></pre>

<pre><tt>
template&lt;bool isRequest, typename Fields = fields&gt;
class header
{
};
</tt></pre>

</body>
