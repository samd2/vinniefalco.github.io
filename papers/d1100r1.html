<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8">
    <title>Efficient composition with DynamicBuffer</title>
    <style type="text/css">
    p {text-align:justify}
    li {text-align:justify}
    blockquote.note
    {
        background-color:#E0E0E0;
        padding-left: 15px;
        padding-right: 15px;
        padding-top: 1px;
        padding-bottom: 1px;
    }
    p.note
    {
        background-color:#E0E0E0;
        padding-left: 15px;
        padding-right: 15px;
        padding-top: 1px;
        padding-bottom: 1px;
    }
    ins { background-color: #CCFFCC; }
    del { background-color: #FFCCCC; }
    .insert { background-color: #CCFFCC; }
    address {text-align:right;}
    h1 {text-align:center;}
    span.comment {color:#C80000;}
    code {white-space:pre;}
    </style>
</head>
<body>
<pre>
Doc. no:  P1100R0
Audience: LEWG
Date:     2019-02-12
Reply-To: Vinnie Falco (<a href="mailto:vinnie.falco@gmail.com">vinnie.falco@gmail.com</a>)
          Damian Jarek (<a href="mailto:damian.jarek93@gmail.com">damian.jarek93@gmail.com</a>)
</pre>
<hr>
<h1>Efficient composition with DynamicBuffer</h1>

<h2>Contents</h2>

<ul>
<li><a href="#FastLook">LEWG FastLook</a></li>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Description">Description</a>
    <ul>
    <li><a href="#Async">Asynchronous Operations</a>
    <li><a href="#Composition">Problem with Composition</a>
    <li><a href="#Exception">Problem with Exceptions</a>
    <li><a href="#Workarounds">Problem with Workarounds</a>
    </ul>
</li>
<li><a href="#Solution">Solution</a></li>
<li><a href="#Revisions">Revision History</a></li>
<li><a href="#References">References</a></li>
<li><a href="#Listing1">Listing 1: <tt>beast::string_buffer</tt></a></li>

</ul>

<a name="FastLook"></a><h2>LEWG FastLook</h2>
<table>
  <tr><th align="left">Target</th></tr>
  <tr><td>
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4734.pdf">
      [N4711] Working Draft, C++ Extensions for Networking
    </a>
  </td></tr>
  <tr><th align="left">Motivation</th></tr>
  <tr><td>
    The transfer of ownership of <em>DynamicBuffer</em> objects required
    by Networking TS in composed operation function signatures forces
    non trivial asynchronous algorithms to needlessly allocate additiona
    memory, which this proposal eliminates.
  </td></tr>
  <tr><th align="left">Basics</th></tr>
  <tr><td>Lorem Ipsum</td></tr>
  <tr><th align="left">History</th></tr>
  <tr><td>
    <ul>
      <li><b>revision 1:</b> Add FastLook, source code</li>
    </ul>
  </td></tr>
</table>


<a name="Introduction"></a><h2>Introduction</h2>
<p>
This paper describes a design flaw in the specification of the
<b>DynamicBuffer</b> concept found in [networking.ts], which prevents efficient
composition of asynchronous operations accepting an instance of a dynamic
buffer. The proposed remedy reverts back some of the differences in the TS from
its precursor library Asio (and Boost.Asio) by making <b>DynamicBuffer</b> a
true storage type.
</p>

<a name="Description"></a><h2>Description</h2>

<p>
Most network algorithms accept fixed-size buffers as input, output, or both,
in their signatures and contracts. For operations where the caller cannot easily
determine ahead of time the storage requirements needed for an algorithm to
meet its post-conditions, [networking.ts] introduces the <b>DynamicBuffer</b> concept:
</p>
<blockquote>
A dynamic buffer encapsulates memory storage that may be automatically
resized as required, where the memory is divided into two regions: readable
bytes followed by writable bytes. [buffer.reqmts.dynamicbuffer]
</blockquote>
<p>
Readable and writable bytes returned by a dynamic buffer are represented
respectively by the <b>ConstBufferSequence</b> and <b>MutableBufferSequence</b>
concepts defined in the TS. These sequences are a special type of range whose
element type is a span of bytes. Network algorithms append data to the dynamic
buffer in two steps. First, a buffer sequence representing writable bytes is
obtained by calling <tt>prepare</tt>. Then, after the algorithm has placed zero
or more bytes at the beginning of the sequence the function <tt>commit</tt> is
called to move some or all of that data to the sequence representing the readable
bytes. The term "move" here is notional: the dynamic buffer concept does not
require (nor disallow) a memory move. The following code reads from a
socket into a dynamic buffer:
</p>
<blockquote><pre>
string s;
dynamic_string_buffer b{s}; // dynamic_string_buffer is defined by the TS
auto const bytes_transferred = socket.read_some(b.prepare(1024)); // read up to 1024 bytes
b.commit(bytes_transferred);
assert(s.size() == bytes_transferred);
</pre></blockquote>
<p>
As can be seen in the preceding code, an instance of <tt>dynamic_string_buffer</tt>
does not own its storage. Overwhelming feedback from users indicates they wish
to use traditional types like <tt>string</tt> or <tt>vector</tt> to store their
data. The TS improves on its predecessor Asio by providing the types
<tt>dynamic_string_buffer</tt> and <tt>dynamic_vector_buffer</tt> to achieve
this goal (subsequent discussions will refer only to <tt>dynamic_string_buffer</tt>,
but also apply to <tt>dynamic_vector_buffer</tt>). The TS provides a family of
algorithms which allow the code above to be expressed more succinctly by
passing the dynamic buffer instead of the buffer sequence representing the
writable bytes. To facilitiate construction and lifetime management of these
dynamic buffers, the TS function <tt>dynamic_buffer</tt> is overloaded for
various container types to return a dynamic buffer instance, as seen in this
synchronous example:
</p>
<blockquote><pre>
string s;
auto const bytes_transferred = read(socket, dynamic_buffer(s));
assert(s.size() == bytes_transferred);
</pre></blockquote>
<p>
Given the semantics of dynamic buffers implied by the wording, instances of
dynamic buffers behave more like references to storage types rather than
storage types, as copies refer to the same underlying storage. This can be
seen in the declaration of <tt>dynamic_string_buffer</tt> which meets
the requirements of <b>DynamicBuffer</b>:
</p>
<blockquote><pre>
template &lt;typename Elem, typename Traits, typename Allocator&gt;
class dynamic_string_buffer
{
  [&hellip;]
private:
  std::basic_string&lt;Elem, Traits, Allocator&gt;&amp; string_;
  std::size_t size_;
  const std::size_t max_size_;
};
</pre></blockquote>
<p>
A dynamic string buffer contains a reference to the underlying string. Copies
of a dynamic string buffer refer to the same string. Note that the dynamic
string buffer also contains some state: the <tt>size_</tt> and <tt>max_size_</tt>
data members. This additional metadata informs the dynamic string buffer of
the boundaries between the readable and writable bytes, as well as the maximum
allowed size of the total of the readable and writable bytes.
<p/>

<a name="Async"></a><h3>Asynchronous Operations</h3>
<p>
Thus far we have shown synchronous (blocking) examples. Asynchronous algorithms
are started by a call to an <em>initiating function</em> which returns immediately.
When the operation has completed, the implementation invokes a caller-provided
function object called a <em>completion handler</em> with the result of the
operation, usually indicated by an error code and possible additional
data such as the number of bytes transacted. Here is a typical signature of an
asynchronous TS algorithm which accepts a dynamic buffer instance:
</p>
<blockquote><pre>
<i>// 17.10 [networking.ts::buffer.async.read.until], asynchronous delimited read operations:</i>

template&lt;
  class AsyncReadStream,
  class DynamicBuffer,
  class CompletionToken&gt;
<i>DEDUCED</i> async_read_until(
  AsyncReadStream&amp; s,
  DynamicBuffer&amp;&amp; b,
  char delim,
  CompletionToken&amp;&amp; token);
</pre></blockquote>
<p>
Since the initiating function returns immediately, it is necessary for the
asynchronous operation to manage the lifetime of the dynamic buffer parameter.
Guidance for doing so is given in the TS:
</p>
<blockquote>
<b>13.2.7.5 Lifetime of initiating function arguments [async.reqmts.async.lifetime]</b>
<p>
1. Unless otherwise specified, the lifetime of arguments to initiating functions shall be treated as 
follows: [&hellip;] the implementation does not assume the validity of the argument after the initiating 
function completes [&hellip;] The implementation may make copies of the argument, and all copies shall be
destroyed no later than immediately after invocation of the completion handler.
</p>
</blockquote>
<p>
Given that the requirement for dynamic buffers is that they are <b>MoveConstructible</b>,
a sensible implementation will make a decay-copy of the argument. An implementation
authored by the principal architect of the TS, does precisely that:
</p>
<blockquote><pre>
namespace detail {

template &lt;
    typename AsyncReadStream,
    typename DynamicBuffer,
    typename ReadHandler&gt;
class read_until_delim_op
{
public:
    // Note: DeducedDynamicBuffer will be DynamicBuffer plus cv-ref qualifiers
    template &lt;typename DeducedDynamicBuffer&gt;
    read_until_delim_op(
        AsyncReadStream&amp; stream,
        DeducedDynamicBuffer&amp;&amp; buffers,
        char delim, ReadHandler&amp; handler)
    : [&hellip;]
      buffers_(std::forward&lt;DeducedDynamicBuffer&gt;(buffers))
      [&hellip;]
    {
    }
    [&hellip;]
    void operator()(const std::error_code& ec,
                    std::size_t bytes_transferred, int start = 0);
    [&hellip;]
    DynamicBuffer buffers_;
    [&hellip;]
};

} // detail

template &lt;
    typename AsyncReadStream,
    typename DynamicBuffer,
    typename ReadHandler&gt;
NET_TS_INITFN_RESULT_TYPE(ReadHandler,
    void (std::error_code, std::size_t))
async_read_until(
    AsyncReadStream&amp; s,
    DynamicBuffer&amp;&amp; buffers,
    char delim,
    ReadHandler&amp;&amp; handler)
{
  // If you get an error on the following line it means that your handler does
  // not meet the documented type requirements for a ReadHandler.
  NET_TS_READ_HANDLER_CHECK(ReadHandler, handler) type_check;

  async_completion&lt;ReadHandler,
    void (std::error_code, std::size_t)&gt; init(handler);

  detail::read_until_delim_op&lt;
    AsyncReadStream,
    typename std::decay&lt;DynamicBuffer&gt;::type,
    NET_TS_HANDLER_TYPE(ReadHandler, void (std::error_code, std::size_t))&gt;(
        s,
        std::forward&lt;DynamicBuffer&gt;(buffers),
        delim,
        init.completion_handler)(std::error_code(), 0, 1);

  return init.result.get();
}
</pre></blockquote>
<p>
Further evidence that a dynamic buffer represents a lightweight non-owning
reference to storage is provided by this quote from LWG issue by the same
author as the TS:
</p>
<blockquote>
Asio's implementation (and the intended specification) performs <tt>DECAY_COPY(b)</tt>
in the <tt>async_read</tt>, <tt>async_write</tt>, and <tt>async_read_until</tt>
initiating functions. All operations performed on b are actually performed on
that decay-copy, or on a move-constructed descendant of it. <b>The copy is intended 
to refer to the same underlying storage and be otherwise interchangeable with
the original in every way</b>. <em>[Ed: emphasis added]</em>
</blockquote>

<p>
When asynchronous algorithms are constructed from calls to other initiating functions,
the result is called a <em>composed operation</em>. For example, <tt>async_read</tt> may be 
implemented in terms of zero or more calls to a stream's <tt>async_read_some</tt> algorithm. 
Layers of composition may be added to arbitrary degree, permitting algorithms of
significant complexity to be developed. A composed operation is typically implemented
as a movable function object containing additional state. When the composed
operation calls an intermediate initiating function, it passes <tt>std::move(*this)</tt>
as the completion handler. This idiom, informally known as "stack-ripping" is used for
reasons related to the optimization of memory allocation during asynchronous continuations
(and beyond the scope of this paper). Here is the function call operator for the
<tt>async_read_until</tt> operation described above:
</p>
<blockquote><pre>
void read_until_op::operator()(const std::error_code& ec,
                               std::size_t bytes_transferred, int start = 0)
{
    ...
    
    // Start a new asynchronous read operation to obtain more data.
    stream_.async_read_some(buffers_.prepare(bytes_to_read), std::move(*this));

    ...
}
</pre></blockquote>
<p>
Care must be taken when using this idiom, as the memory location of data
members belonging to the function object will necessarily change every time
an initiating function is invoked. The implication is that lvalue references
belonging to any of the data members of the function object may not
be passed to intermediate initiating functions. This prevents internal
interfaces where dynamic buffers are passed by reference.
</p>



<a name="Composition"></a><h3>Problem with Composition</h3>
<p>
When only one composed operation handles the dynamic buffer, things seem to
work. However, if a composed operation wishes to invoke another composed
operation on that dynamic buffer, a problem arises. Consider a composed
operation <tt>async_http_read</tt> which accepts a dynamic buffer, and is
implemented in terms of zero or more calls to <tt>async_http_read_some</tt>,
which also accepts the same dynamic buffer. When <tt>async_http_read_some</tt>
is invoked, it takes ownership of the buffer via move. However, if
<tt>async_http_read</tt> needs to invoke <tt>async_http_read_some</tt>
again to fufill its contract, it cannot do so without depending on undefined
behavior. This is because on the second and subsequent invocations of
<tt>async_http_read_some</tt>, the buffer is in a moved-from state, and
the specification of <b>DynamicBuffer</b> is silent on the condition of
moved-from objects. This can be seen in the implementation of the functions
described above, which come from the Boost.Beast [2] library:
</p>
<blockquote><pre>
template&lt;class Stream, class DynamicBuffer,
    bool isRequest, class Derived, class Condition,
        class Handler&gt;
class read_http_op : public boost::asio::coroutine
{
    Stream& stream_;
    DynamicBuffer buffer_;
    basic_parser<isRequest, Derived>& parser_;
    std::size_t bytes_transferred_ = 0;
    Handler handler_;
    bool cont_ = false;

public:
    [&hellip;]

    void
    operator()(
        error_code ec,
        std::size_t bytes_transferred = 0,
        bool cont = true)
    {
        cont_ = cont;
        BOOST_ASIO_CORO_REENTER(*this)
        {
            if(Condition{}(p_))
            {
                BOOST_ASIO_CORO_YIELD
                boost::asio::post(stream_.get_executor(),
                    bind_handler(std::move(*this), ec));
                goto upcall;
            }
            for(;;)
            {
                // The call to async_http_read_some will produce
                // undefined behavior on the second and subsequent
                // calls, since buffer_ is in the moved-from state:
                //
                BOOST_ASIO_CORO_YIELD
                async_http_read_some(
                    stream_, std::move(buffer_), parser_, std::move(*this));

                if(ec)
                    goto upcall;
                bytes_transferred_ += bytes_transferred;
                if(Condition{}(p_))
                    goto upcall;
            }
        upcall:
            handler_(ec, bytes_transferred_);
        }
    }
};
</pre></blockquote>

<!----------------------------------------------------------------------------->

<a name="Exception"></a><h3>Problem with Exceptions</h3>
<p>
Another design problem caused by adding metadata to the dynamic buffer concept
is illustrated in the following example code:
</p>
<table>
<tr><th>Before</th><th>After</th></tr>
<tr><td>
<blockquote><pre>
template&lt;class MutableBufferSequence&gt;
std::size_t read(const MutableBufferSequence&amp;)
{
    throw std::exception{};
}

int main()
{
    std::string s;
    assert(s.empty());
    try
    {
        auto b = boost::asio::dynamic_buffer(s);
        b.commit(read(b.prepare(32)));
    }
    catch(const std::exception&amp;)
    {
        assert(s.empty()); // fails
    }
}
</pre></blockquote>
</td><td>
<blockquote><pre>
template&lt;class MutableBufferSequence&gt;
std::size_t read(const MutableBufferSequence&amp;)
{
    throw std::exception{};
}

int main()
{
    dynamic_string_buffer b;
    assert(b.get().empty());
    try
    {
        b.commit(read(b.prepare(32)));
    }
    catch(const std::exception&amp;)
    {
        assert(b.get().empty());       // okay

        std::string s = b.release();   // take ownership
        assert(s.empty());             // okay
    }
}
</pre></blockquote>
</td></tr>
</table>
<p>
While not technically incorrect, it may be surprising to the user that
the string contains additional value-initialized data which was not part
of the original readable bytes (which in this case was empty). The wording of
<b>DynamicBuffer</b> and <tt>dynamic_string_buffer</tt> do not address
the effect of exceptions on state of the readable bytes in the underlying
container at all.
</p>

<!----------------------------------------------------------------------------->

<a name="Workarounds"></a><h3>Problem with Workarounds</h3>
<p>
The problem of composition can be solved using the current specification of
<b>DynamicBuffer</b> by creating a copyable, reference-counted wrapper which
holds a decay-copy of the dynamic buffer argument. Here is a partial sketch
of that wrapper:
</p>
<blockquote><pre>
template&lt;class DynamicBuffer&gt;
class shared_buffer
{
    std::shared_ptr&lt;DynamicBuffer&gt; p_;

public:
    template&lt;class DeducedDynamicBuffer&gt;
    explicit shared_buffer(DeducedDynamicBuffer&amp;&amp; b)
        : p_(std::make_shared&lt;DynamicBuffer&gt;(std::forward&lt;DeducedDynamicBuffer&gt;(b)))
    {
    }

    [&hellip;]

    mutable_buffers_type prepare(std::size_t n);
    void commit(std::size_t);
};
</pre></blockquote>
<p>
An existing initiating function may be adjusted to use the wrapper instead,
as shown:
</p>
<blockquote><pre>
template &lt;
    typename AsyncReadStream,
    typename DynamicBuffer,
    typename ReadHandler&gt;
NET_TS_INITFN_RESULT_TYPE(ReadHandler,
    void (std::error_code, std::size_t))
async_read_until(
    AsyncReadStream&amp; s,
    DynamicBuffer&amp;&amp; buffers,
    char delim,
    ReadHandler&amp;&amp; handler)
{
  // If you get an error on the following line it means that your handler does
  // not meet the documented type requirements for a ReadHandler.
  NET_TS_READ_HANDLER_CHECK(ReadHandler, handler) type_check;

  async_completion&lt;ReadHandler,
    void (std::error_code, std::size_t)&gt; init(handler);

  read_until_delim_op&lt;
    AsyncReadStream,
    shared_buffer&lt;typename std::decay&lt;DynamicBuffer&gt;::type&gt;,
    NET_TS_HANDLER_TYPE(ReadHandler, void (std::error_code, std::size_t))&gt;(
        s,
        shared_buffer&lt;typename std::decay&lt;DynamicBuffer&gt;::type&gt{std::forward&lt;DynamicBuffer&gt;(buffers)},
        delim,
        init.completion_handler)(std::error_code(), 0, 1);

  return init.result.get();
}
</pre></blockquote>
<p>
This workaround comes at the expense of one or more additional unnecessary
dynamic allocations. Utilizing the workaround would sacrifice an important
C++ value: zero-cost abstractions.
</p>

<!----------------------------------------------------------------------------->

<a name="Solution"></a><h2>Solution</h2>
<p>
The Net.TS predecessors Asio and Boost.Asio offered only the single
concrete type <tt>basic_streambuf</tt> which addressed the problem of
stream algorithms which need to write a dynamic number of octets. The
interface to <tt>basic_streambuf</tt> almost perfectly matches the
requirements of <b>DynamicBuffer</b>.
Field experience showed that users had trouble manipulating buffer sequences,
often writing code which performed unnecessary allocate/copy/free cycles
to get the data in the format they desired. Users loudly declared the
desire to send and receive their data using traditional containers such
as <tt>string</tt> and <tt>vector</tt> with which they are already very
familiar.
</p>
<p>
To support the use of strings and vectors in stream algorithms, the
<b>DynamicBuffer</b> concept is fashioned as a non-owning reference wrapper
to a supported container type whose lifetime is managed by the caller. Algorithms
which accept dynamic buffer parameters use a forwarding reference, and take
ownership via decay-copy. Net.TS provides some functions which accept a
reference to a user-managed container and return a suitable wrapper. These
functions are designed for ease of use, as they may be invoked directly at
call sites:
</p>
<blockquote><pre>
<i>// 16.14 [networking.ts::buffer.dynamic.creation], dynamic buffer creation:</i>

template&lt;class T, class Allocator&gt;
  dynamic_vector_buffer&lt;T, Allocator&gt;
  dynamic_buffer(vector&lt;T, Allocator&gt;&amp; vec) noexcept;
template&lt;class T, class Allocator&gt;
  dynamic_vector_buffer&lt;T, Allocator&gt;
  dynamic_buffer(vector&lt;T, Allocator&gt;&amp; vec, size_t n) noexcept;

template&lt;class CharT, class Traits, class Allocator&gt;
  dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;
  dynamic_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str) noexcept;
template&lt;class CharT, class Traits, class Allocator&gt;
  dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;
  dynamic_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str, size_t n) noexcept;
</pre></blockquote>
<p>
The solution we propose is to change the semantics of <b>DynamicBuffer</b>
to represent a true storage type rather than a hybrid reference with metadata.
Instances of dynamic buffers will be passed by reference, and callers will
be required to manage the lifetime of dynamic buffer objects for the duration
of any asynchronous operations. As the caller is already responsible for
maintaining the lifetime of the stream, and the <tt>string</tt> or <tt>vector</tt>
under the old scheme, maintaining the lifetime of the dynamic buffer in the
new scheme poses no additional burden. To solve the problem of exceptions,
our solution refactors the dynamic buffer wrappers to own their corresponding
string and vector. The caller can only take ownership of the container by
calling a member function. The implementation then has the opportunity to
adjust the container to reflect the correct state before the caller receives
the value.
</p>
<p>
We believe that there is a tension between ease of use and utility. The current
specification provides ease of use but lacks utility, specifically the ability
to compose higher level operations out of lower level ones which operate on
dynamic buffers. The solution we propose goes in the opposite direction,
sacrificing some ease of use in exchange for the ability to compose. The
author of this paper favor composition over ease of use for a few reasons.
First, because C++ should always prioritize zero-cost abstractions as
a primary factor to differentiate itself from other languages. And second,
because the entirety of Net.TS provides <em>low-level abstractions</em>. Most
users should not be concerning themselves with interacting at the raw TCP/IP
level. Instead they should be working with high level interfaces such as
HTTP client APIs, WebSocket framework APIs, REST SDKs, and the like. These
high level interfaces do not exist yet, but with the standardization of low
level networking provided in Net.TS we are confident they will arrive in
due time.
</p>
<p>
Note that writing asynchronous code in a clean style which uses all the
modern idioms of Asio and Net.TS is quite a difficult endeavor, as evidenced
by the distinct lack of open source libraries built on Asio which follow
best practices (despite Asio having been available for over a decade).
Furthermore the number of people who need to author components which interact
directly with low-level interfaes such as Asio or Net.TS should be few in number.
Therefore, we favor a Net.TS specification which addresses the needs for
writers of specialized middleware and high-level interfaces over ordinary
users.
</p>



<a name="Wording"></a><h2>Proposed Wording</h2>
<p>This wording is relative to <a href="http://wg21.link/n4734">N4734</a>.</p>

<blockquote class="note">
<p>[<i>Drafting note:</i> The project editor is kindly asked to replace all occurrences of 
<tt>DynamicBuffer&amp;&amp;</tt> with <tt>DynamicBuffer&amp;</tt> as indicated by the provided
wording changes below. &mdash; <i>end drafting note</i>]
</p>
</blockquote>

<ol>
<li><p>Modify 16.1 [networking.ts::buffer.synop], header <tt>&lt;experimental/buffer&gt;</tt> synopsis, 
as indicated:</p>
<blockquote><pre>
[&hellip;]
<i>// 16.11 [networking.ts::buffer.creation], buffer creation:</i>
[&hellip;]

template&lt;class T, class Allocator<ins> = allocator&lt;T&gt;</ins>&gt;
class dynamic_vector_buffer;

template&lt;class CharT, class Traits<ins> = char_traits&lt;CharT&gt;</ins>, class Allocator<ins> = allocator&lt;CharT&gt;</ins>&gt;
class <ins>basic_</ins>dynamic_string_buffer;

<ins>using dynamic_string_buffer = basic_dynamic_string_buffer&lt;char&gt;;</ins>

<del><i>// 16.14 [networking.ts::buffer.dynamic.creation], dynamic buffer creation:</i></del>

<del>template&lt;class T, class Allocator&gt;
  dynamic_vector_buffer&lt;T, Allocator&gt;
  dynamic_buffer(vector&lt;T, Allocator&gt;&amp; vec) noexcept;
template&lt;class T, class Allocator&gt;
  dynamic_vector_buffer&lt;T, Allocator&gt;
  dynamic_buffer(vector&lt;T, Allocator&gt;&amp; vec, size_t n) noexcept;
</del>

<del>template&lt;class CharT, class Traits, class Allocator&gt;
  dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;
  dynamic_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str) noexcept;
template&lt;class CharT, class Traits, class Allocator&gt;
  dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;
  dynamic_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str, size_t n) noexcept;</del>

[&hellip;]
<i>// 17.5 [networking.ts::buffer.read], synchronous read operations:</i>
[&hellip;]

template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
              CompletionCondition completion_condition);
template&lt;class SyncReadStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
              CompletionCondition completion_condition, error_code&amp; ec);

<i>// 17.6 [networking.ts::buffer.async.read], asynchronous read operations:</i>              
[&hellip;]

template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read(AsyncReadStream&amp; stream,
                     DynamicBuffer&amp;<del>&amp;</del> b, CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer,
  class CompletionCondition, class CompletionToken&gt;
    <i>DEDUCED</i> async_read(AsyncReadStream&amp; stream,
                       DynamicBuffer&amp;<del>&amp;</del> b,
                       CompletionCondition completion_condition,
                       CompletionToken&amp;&amp; token);

<i>// 17.7 [networking.ts::buffer.write], synchronous write operations:</i>                       
[&hellip;]

template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del>; b);
template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b, error_code&amp; ec);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
               CompletionCondition completion_condition);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
               CompletionCondition completion_condition, error_code&amp; ec);

<i>// 17.8 [networking.ts::buffer.async.write], asynchronous write operations:</i>               
[&hellip;]

template&lt;class AsyncWriteStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_write(AsyncWriteStream&amp; stream,
                      DynamicBuffer&amp;<del>&amp;</del> b, CompletionToken&amp;&amp; token);
template&lt;class AsyncWriteStream, class DynamicBuffer,
  class CompletionCondition, class CompletionToken&gt;
    <i>DEDUCED</i> async_write(AsyncWriteStream&amp; stream,
                        DynamicBuffer&amp;<del>&amp;</del> b,
                        CompletionCondition completion_condition,
                        CompletionToken&amp;&amp; token);

<i>// 17.9 [networking.ts::buffer.read.until], synchronous delimited read operations:</i>                        

template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b, char delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b,
                    char delim, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b, string_view delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b,
                    string_view delim, error_code&amp; ec);

<i>// 17.10 [networking.ts::buffer.async.read.until], asynchronous delimited read operations:</i>

template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;<del>&amp;</del> b, char delim,
                           CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;<del>&amp;</del> b, string_view delim,
                           CompletionToken&amp;&amp; token);

[&hellip;]
</pre></blockquote>
</li>

<li>
<p>Modify 16.2.4 [networking.ts::buffer.reqmts.dynamicbuffer], as indicated:</p>

<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- A type <tt>X</tt> meets the <tt>DynamicBuffer</tt> requirements if it satisfies
the requirements of <tt>Destructible</tt> (C++ 2014 [destructible])
<del>and <tt>MoveConstructible</tt> (C++ 2014 [moveconstructible]),</del>
as well as the additional requirements listed in Table 14.
</p>
</blockquote>
</li>

<li><p>Modify 16.12 [networking.ts::buffer.dynamic.vector], as indicated:</p>

<blockquote>
<blockquote><pre>
[&hellip;]

template&lt;class T, class Allocator<ins> = allocator&lt;T&gt;</ins>&gt;
class dynamic_vector_buffer
{
public:
  <em>// types:</em>
  <ins>using value_type = vector&lt;T, Allocator&gt;;</ins>
  using const_buffers_type = const_buffer;
  using mutable_buffers_type = mutable_buffer;
  
  <em>// constructors:</em>
  <ins>dynamic_vector_buffer();</ins>
  <ins>explicit dynamic_vector_buffer(size_t maximum_size);</ins>
  explicit dynamic_vector_buffer(<del>vector&lt;T, Allocator&gt;</del><ins>value_type</ins>&amp;<ins>&amp;</ins> vec) noexcept;
  dynamic_vector_buffer(<del>vector&lt;T, Allocator&gt;</del><ins>value_type</ins>&amp;<ins>&amp;</ins> vec, size_t maximum_size)<del> noexcept</del>;
  dynamic_vector_buffer(dynamic_vector_buffer&amp;&amp;<ins> other</ins>)<del> = default</del><ins> noexcept</ins>;
  
  <ins>dynamic_vector_buffer&amp; operator=(const dynamic_vector_buffer&amp;) = delete;</ins>
  
  <em>// members:</em>
  size_t size() const noexcept;
  size_t max_size() const noexcept;
  <ins>void max_size(size_t maximum_size) noexcept;</ins>
  size_t capacity() const noexcept;
  const_buffers_type data() const noexcept;
  mutable_buffers_type prepare(size_t n);
  void commit(size_t n);
  void consume(size_t n);
  <ins>span&lt;const T&gt; get() const noexcept;</ins>
  <ins>value_type release();</ins>

private:
  <del>vector&lt;T, Allocator&gt;&amp;</del> <ins>value_type</ins> vec_; <em>// exposition only</em>
  size_t size_; <em>// exposition only</em>
  <del>const</del> size_t max_size_; <em>// exposition only</em>
};

[&hellip;]
</pre></blockquote>
<p>
-2- [&hellip;]
<p/>
-3- [&hellip;]
</p>
<pre>
<ins>dynamic_vector_buffer();</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Default-constructs <tt>vec_</tt>. Initializes <tt>size_</tt> with <tt>0</tt>, and 
<tt>max_size_</tt> with <tt>vec_.max_size()</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>explicit dynamic_vector_buffer(size_t maximum_size);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Default-constructs <tt>vec_</tt>. Initializes <tt>size_</tt> with <tt>0</tt>, and 
<tt>max_size_</tt> with <tt>maximum_size</tt>.</ins>
</p>
</blockquote>
<pre>
explicit dynamic_vector_buffer(<del>vector&lt;T, Allocator&gt;</del><ins>value_type</ins>&amp;<ins>&amp;</ins> vec) noexcept;
</pre>
<blockquote>
<p>
-4- <em>Effects:</em> Initializes <tt>vec_</tt> with <tt><ins>std::move(</ins>vec<ins>)</ins></tt>,
  <tt>size_</tt> with <tt>vec<ins>_</ins>.size()</tt>, and <tt>max_size_</tt> with <tt>vec<ins>_</ins>.max_size()</tt>.
</p>
</blockquote>
<pre>
dynamic_vector_buffer(<del>vector&lt;T, Allocator&gt;</del><ins>value_type</ins>&amp;<ins>&amp;</ins> vec,
                      size_t maximum_size) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-5- <em>Requires:</em> <tt>vec.size() &lt;= maximum_size</tt>.
<p/>
-6- <em>Effects:</em> Initializes <tt>vec_</tt> with <tt><ins>std::move(</ins>vec<ins>)</ins></tt>,
  <tt>size_</tt> with <tt>vec<ins>_</ins>.size()</tt>, and <tt>max_size_</tt> with <tt>maximum_size</tt>.
</p>
</blockquote>
<pre>
<ins>dynamic_vector_buffer(dynamic_vector_buffer&amp;&amp; other) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Initializes <tt>vec_</tt> with <tt>std::move(other.vec_)</tt>,
  <tt>size_</tt> with <tt>other.size_</tt>, and <tt>max_size_</tt> with <tt>other.max_size_</tt>. Then calls
  <tt>other.vec_.clear();</tt> and assigns 0 to <tt>other.size_</tt>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
size_t max_size() const noexcept;
</pre>
<blockquote>
<p>
-8- <i>Returns:</i> <tt>max_size_</tt>.
</p>
</blockquote>
<pre>
<ins>void max_size(size_t maximum_size);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Requires:</em> <tt>size() &lt;= maximum_size</tt>.</ins> 
<p/>
<ins>-?- <em>Effects:</em> Performs <tt>max_size_ = maximum_size</tt>.</ins>
</p>
</blockquote>
[&hellip;]
<pre>
void consume(size_t n);
</pre>
<blockquote>
<p>
-15- <i>Effects:</i> [&hellip;]
</p>
</blockquote>
<pre>
<ins>span&lt;const T&gt; get() const noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Returns:</em> <tt>span&lt;const T&gt;(vec_.data(), size_)</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>value_type release();</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Equivalent to:</ins>
<blockquote>
<pre><ins>
vec_.resize(size_);
value_type tmp = std::move(vec_);
vec_.clear();
size_ = 0;
return tmp;
</ins></pre>
</blockquote>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 16.13 [networking.ts::buffer.dynamic.string], as indicated:</p>

<blockquote>
<blockquote><pre>
template&lt;class CharT, class Traits<ins> = char_traits&lt;CharT&gt;</ins>, class Allocator<ins> = allocator&lt;CharT&gt;</ins>&gt;
class <ins>basic_</ins>dynamic_string_buffer
{
public:
  <em>// types:</em>
  <ins>using value_type = basic_string&lt;CharT, Traits, Allocator&gt;;</ins>
  using const_buffers_type = const_buffer;
  using mutable_buffers_type = mutable_buffer;

  <em>// constructors:</em>
  <ins>basic_dynamic_string_buffer();</ins>
  <ins>explicit basic_dynamic_string_buffer(size_t maximum_size);</ins>
  explicit <ins>basic_</ins>dynamic_string_buffer(<del>basic_string&lt;CharT, Traits, Allocator&gt;</del><ins>value_type</ins>&amp;<ins>&amp;</ins> str) noexcept;
  <ins>basic_</ins>dynamic_string_buffer(<del>basic_string&lt;CharT, Traits, Allocator&gt;</del><ins>value_type</ins>&amp;<ins>&amp;</ins> str, size_t maximum_size) <del>noexcept</del>;
  <ins>basic_</ins>dynamic_string_buffer(<ins>basic_</ins>dynamic_string_buffer&amp;&amp;<ins> other</ins>)<del> = default</del><ins> noexcept</ins>;

  <ins>basic_dynamic_string_buffer&amp; operator=(basic_dynamic_string_buffer&amp;&amp;) = delete;</ins>
  
  <em>// members:</em>
  size_t size() const noexcept;
  size_t max_size() const noexcept;
  <ins>void max_size(size_t maximum_size) noexcept;</ins>
  size_t capacity() const noexcept;
  const_buffers_type data() const noexcept;
  mutable_buffers_type prepare(size_t n);
  void commit(size_t n) noexcept;
  void consume(size_t n);
  <ins>basic_string_view&lt;CharT, Traits&gt; get() const noexcept;</ins>
  <ins>value_type release();</ins>

private:
  <del>basic_string&lt;CharT, Traits, Allocator&gt;&amp;</del> <ins>value_type</ins> str_; <em>// exposition only</em>
  size_t size_; <em>// exposition only</em>
  <del>const </del>size_t max_size_; <em>// exposition only</em>
};
</pre>
</blockquote>
<p>
-2- [&hellip;]
<p/>
-3- [&hellip;]
</p>
<pre>
<ins>basic_dynamic_string_buffer();</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Default-constructs <tt>str_</tt>. Initializes <tt>size_</tt> with <tt>0</tt>, and 
<tt>max_size_</tt> with <tt>str_.max_size()</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>explicit basic_dynamic_string_buffer(size_t maximum_size);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Default-constructs <tt>str_</tt>. Initializes <tt>size_</tt> with <tt>0</tt>, and 
<tt>max_size_</tt> with <tt>maximum_size</tt>.</ins>
</p>
<p>[&hellip;]</p>
</blockquote>
<pre>
explicit <ins>basic_</ins>dynamic_string_buffer(<del>basic_string&lt;CharT, Traits, Allocator&gt;</del><ins>value_type</ins>&amp;<ins>&amp;</ins> str) noexcept;
</pre>
<blockquote>
<p>
-4- <em>Effects:</em> Initializes <tt>str_</tt> with <tt><ins>std::move(</ins>str<ins>)</ins></tt>,
  <tt>size_</tt> with <tt>str<ins>_</ins>.size()</tt>, and <tt>max_size_</tt> with <tt>str<ins>_</ins>.max_size()</tt>
</p>
</blockquote>
<pre>
<ins>basic_</ins>dynamic_string_buffer(<del>basic_string&lt;CharT, Traits, Allocator&gt;</del><ins>value_type</ins>&amp;<ins>&amp;</ins> str,
                            size_t maximum_size)<del> noexcept</del>;
</pre>
<blockquote>
<p>
-5- <em>Requires:</em> <tt>str.size() &lt;= maximum_size</tt>.
</p>
<p>
-6- <em>Effects:</em> Initializes <tt>str_</tt> with <tt><ins>std::move(</ins>str<ins>)</ins></tt>,
  <tt>size_</tt> with <tt>str<ins>_</ins>.size()</tt>, and <tt>max_size_</tt> with <tt>maximum_size</tt>.
</p>
</blockquote>
<pre>
<ins>basic_dynamic_string_buffer(basic_dynamic_string_buffer&amp;&amp; other) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Initializes <tt>str_</tt> with <tt>std::move(other.str_)</tt>,
  <tt>size_</tt> with <tt>other.size_</tt>, and <tt>max_size_</tt> with <tt>other.max_size_</tt>. Then calls
  <tt>other.str_.clear();</tt> and assigns 0 to <tt>other.size_</tt>.</ins>
</p>
<p>[&hellip;]</p>
</blockquote>
<pre>
size_t max_size() const noexcept;
</pre>
<blockquote>
<p>
-8- <em>Returns:</em> <tt>max_size_</tt>.
</p>
</blockquote>
<pre>
<ins>void max_size(size_t maximum_size);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Requires:</em> <tt>size() &lt;= maximum_size</tt>.</ins> 
<p/>
<ins>-?- <em>Effects:</em> Performs <tt>max_size_ = maximum_size</tt>.</ins>
</p>
</blockquote>
<p>[&hellip;]</p>
<pre>
void consume(size_t n);
</pre>
<blockquote>
<p>
-15- <i>Effects:</i> [&hellip;]
</p>
</blockquote>
<pre>
<ins>basic_string_view&lt;CharT, Traits&gt; get() const noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Returns:</em> <tt>basic_string_view&lt;CharT, Traits&gt;(str_.data(), size_)</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>value_type release();</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Equivalent to:</ins>
<blockquote>
<pre><ins>
str_.resize(size_);
value_type tmp = std::move(str_);
str_.clear();
size_ = 0;
return tmp;
</ins></pre>
</blockquote>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 16.14 [networking.ts::buffer.dynamic.creation] entirely.</p></li>

<li><p>Modify 17.5 [networking.ts::buffer.read], as indicated:</p>
<blockquote>
<pre>
[&hellip;]

template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
                CompletionCondition completion_condition);
template&lt;class SyncReadStream, class DynamicBuffer,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
                CompletionCondition completion_condition,
                error_code&amp; ec);

[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 17.6 [networking.ts::buffer.async.read], as indicated:</p>
<blockquote>
<pre>
[&hellip;]

template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read(AsyncReadStream&amp; stream,
                     DynamicBuffer&amp;<del>&amp;</del> b, CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionCondition,
  class CompletionToken&gt;
    <i>DEDUCED</i> async_read(AsyncReadStream&amp; stream,
                       DynamicBuffer&amp;<del>&amp;</del> b,
                       CompletionCondition completion_condition,
                       CompletionToken&amp;&amp; token);

[&hellip;]
</pre>
<p>
-14- The program shall ensure <ins>both</ins> the <tt>AsyncReadStream</tt>
object <tt>stream</tt> <ins>and the <tt>DynamicBuffer</tt> object <tt>b</tt>
are</ins><del> is</del> valid until the completion handler for the asynchronous
operation is invoked.
</p>
</blockquote>
</li>

<li><p>Modify 17.7 [networking.ts::buffer.write], as indicated:</p>
<blockquote><pre>
[&hellip;]

template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b);
template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b, error_code&amp; ec);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
               CompletionCondition completion_condition);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
               CompletionCondition completion_condition,
               error_code&amp; ec);

[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 17.8 [networking.ts::buffer.async.write], as indicated:</p>
<blockquote><pre>
[&hellip;]

template&lt;class AsyncWriteStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_write(AsyncWriteStream&amp; stream,
                      DynamicBuffer&amp;<del>&amp;</del> b, CompletionToken&amp;&amp; token);
template&lt;class AsyncWriteStream, class DynamicBuffer, class CompletionCondition,
  class CompletionToken&gt;
    <i>DEDUCED</i> async_write(AsyncWriteStream&amp; stream,
                        DynamicBuffer&amp;<del>&amp;</del> b,
                        CompletionCondition completion_condition,
                        CompletionToken&amp;&amp; token);

[&hellip;]
</pre>
<p>
-14- The program shall ensure both the <tt>AsyncWriteStream</tt> object
<tt>stream</tt> and the <ins><tt>DynamicBuffer</tt> object <tt>b</tt></ins>
<del>memory associated with the dynamic buffer <tt>b</tt></del>
are valid until the completion handler for the asynchronous operation
is invoked.
</p>
</blockquote>
</li>

<li><p>Modify 17.9 [networking.ts::buffer.read.until], as indicated:</p>
<blockquote><pre>
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b, char delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b,
                    char delim, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b, string_view delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b,
                    string_view delim, error_code&amp; ec);

[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 17.10 [networking.ts::buffer.async.read.until], as indicated:</p>
<blockquote><pre>
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;<del>&amp;</del> b, char delim,
                           CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;<del>&amp;</del> b, string_view delim,
                           CompletionToken&amp;&amp; token);

[&hellip;]
</pre>
<p>
-6- The program shall ensure <ins>both</ins> the <tt>AsyncReadStream</tt> object
<tt>stream</tt> <ins>and the <tt>DynamicBuffer</tt> object <tt>b</tt>
are</ins><del> is</del> valid until the completion handler for the
asynchronous operation is invoked.
</p>
</blockquote>
</li>
</ol>

<a name="Revisions"></a><h2>Revisions</h2>
  <ol>
    <li><b>r1</b> Add beast::string buffer, Tony tables</li>
    <li><b>r0</b> Initial paper</li>
  </ol>

<a name="References"></a><h2>References</h2>

[1] <a href="http://cplusplus.github.io/LWG/lwg-active.html#3072">http://cplusplus.github.io/LWG/lwg-active.html#3072</a><br>
[2] <a href="https://github.com/boostorg/beast">https://github.com/boostorg/beast</a><br>

<a name="Listing1"></a><h2>Listing 1: <tt>beast::string_buffer</tt></h2>
<!-- HTML generated using hilite.me --><div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .1em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #408080; font-style: italic">/** A dynamic buffer which uses a string for the internal storage.</span>

<span style="color: #408080; font-style: italic">    This dynamic buffer uses a standard string for the internal</span>
<span style="color: #408080; font-style: italic">    storage. It otherwise behaves, and meets the requirements for,</span>
<span style="color: #408080; font-style: italic">    the &lt;em&gt;DynamicBuffer&lt;/em&gt; named requirements.</span>

<span style="color: #408080; font-style: italic">    The caller may view the readable bytes as a `string_view`, or</span>
<span style="color: #408080; font-style: italic">    optionally take ownership of the string itself by calling</span>
<span style="color: #408080; font-style: italic">    @ref release.</span>

<span style="color: #408080; font-style: italic">    In the current implementation of Networking, algorithms which</span>
<span style="color: #408080; font-style: italic">    operate on dynamic buffers take ownership of the buffer,</span>
<span style="color: #408080; font-style: italic">    presenting a problem when implementing composed operations.</span>
<span style="color: #408080; font-style: italic">    To work around this, the function @ref dynamic_buffer_ref</span>
<span style="color: #408080; font-style: italic">    returns a lightweight movable reference to a dynamic buffer,</span>
<span style="color: #408080; font-style: italic">    which may be passed to networking algorithms which expect</span>
<span style="color: #408080; font-style: italic">    to take ownership.</span>

<span style="color: #408080; font-style: italic">    @par Example</span>
<span style="color: #408080; font-style: italic">    This example demonstrates how to read a line of text into a</span>
<span style="color: #408080; font-style: italic">    @ref string_buffer and return it to the caller as a string,</span>
<span style="color: #408080; font-style: italic">    using the networking algorithm `net::read_until` which wants</span>
<span style="color: #408080; font-style: italic">    to take ownership of the buffer:</span>
<span style="color: #408080; font-style: italic">    @code</span>
<span style="color: #408080; font-style: italic">    template &lt;class SyncReadStream&gt;</span>
<span style="color: #408080; font-style: italic">    std::string get_line (SyncReadStream&amp; stream)</span>
<span style="color: #408080; font-style: italic">    {</span>
<span style="color: #408080; font-style: italic">        string_buffer buffer;</span>
<span style="color: #408080; font-style: italic">        net::read_until(stream, dynamic_buffer_ref(buffer), &quot;\n&quot;);</span>
<span style="color: #408080; font-style: italic">        return buffer.release();</span>
<span style="color: #408080; font-style: italic">    }</span>
<span style="color: #408080; font-style: italic">    @endcode</span>

<span style="color: #408080; font-style: italic">    @tparam CharT The type of character in the string.</span>
<span style="color: #408080; font-style: italic">    For @ref string_buffer this will be `char`.</span>

<span style="color: #408080; font-style: italic">    @tparam Traits The character traits to use.</span>
<span style="color: #408080; font-style: italic">    This will default to `std::char_traits&lt;CharT&gt;`.</span>

<span style="color: #408080; font-style: italic">    @tparam The allocator to use.</span>
<span style="color: #408080; font-style: italic">    This will default to `std::allocator&lt;CharT&gt;`.</span>

<span style="color: #408080; font-style: italic">    @see</span>
<span style="color: #408080; font-style: italic">    </span>
<span style="color: #408080; font-style: italic">    @li @ref string_buffer</span>

<span style="color: #408080; font-style: italic">    @li @ref wstring_buffer</span>

<span style="color: #408080; font-style: italic">    @li &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1100r0.html&quot;&gt;[P1100R0] Efficient composition with DynamicBuffer&lt;/a&gt;</span>
<span style="color: #408080; font-style: italic">*/</span>
<span style="color: #008000; font-weight: bold">template</span><span style="color: #666666">&lt;</span>
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">CharT</span>,
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Traits</span> <span style="color: #666666">=</span> std<span style="color: #666666">::</span>char_traits<span style="color: #666666">&lt;</span>CharT<span style="color: #666666">&gt;</span>,
    <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Allocator</span> <span style="color: #666666">=</span> std<span style="color: #666666">::</span>allocator<span style="color: #666666">&lt;</span>CharT<span style="color: #666666">&gt;</span>
<span style="color: #666666">&gt;</span>
<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">basic_string_buffer</span>
{
<span style="color: #A0A000">public:</span>
    <span style="color: #408080; font-style: italic">/// The type of string used by the dynamic buffer</span>
    <span style="color: #008000; font-weight: bold">using</span> value_type <span style="color: #666666">=</span>
        std<span style="color: #666666">::</span>basic_string<span style="color: #666666">&lt;</span>CharT, Traits, Allocator<span style="color: #666666">&gt;</span>;

    <span style="color: #408080; font-style: italic">/// The type used to represent integral sizes</span>
    <span style="color: #008000; font-weight: bold">using</span> size_type <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">typename</span> value_type<span style="color: #666666">::</span>size_type;

<span style="color: #A0A000">private:</span>

<span style="color: #408080; font-style: italic">/*  Layout:</span>

<span style="color: #408080; font-style: italic">        0        in_          out_      s_.size()    s_.capacity()</span>
<span style="color: #408080; font-style: italic">        |&lt;-------&gt;|&lt;----------&gt;|&lt;----------&gt;|&lt;-----------&gt;|</span>
<span style="color: #408080; font-style: italic">                  |  readable  |  writable  |</span>
<span style="color: #408080; font-style: italic">*/</span>

    std<span style="color: #666666">::</span>basic_string<span style="color: #666666">&lt;</span>CharT, Traits, Allocator<span style="color: #666666">&gt;</span> s_;
    size_type max_ <span style="color: #666666">=</span>
        (std<span style="color: #666666">::</span>numeric_limits<span style="color: #666666">&lt;</span>std<span style="color: #666666">::</span><span style="color: #B00040">size_t</span><span style="color: #666666">&gt;::</span>max)();
    size_type in_ <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
    size_type out_ <span style="color: #666666">=</span> <span style="color: #666666">0</span>;

<span style="color: #A0A000">public:</span>
    <span style="color: #408080; font-style: italic">/// The ConstBufferSequence used to represent the readable bytes.</span>
    <span style="color: #008000; font-weight: bold">using</span> const_buffers_type <span style="color: #666666">=</span> net<span style="color: #666666">::</span>const_buffer;

    <span style="color: #408080; font-style: italic">/// The MutableBufferSequence used to represent the readable bytes.</span>
    <span style="color: #008000; font-weight: bold">using</span> mutable_data_type <span style="color: #666666">=</span> net<span style="color: #666666">::</span>mutable_buffer;

    <span style="color: #408080; font-style: italic">/// The MutableBufferSequence used to represent the writable bytes.</span>
    <span style="color: #008000; font-weight: bold">using</span> mutable_buffers_type <span style="color: #666666">=</span> net<span style="color: #666666">::</span>mutable_buffer;

    <span style="color: #408080; font-style: italic">/// Constructor</span>
    basic_string_buffer() <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">default</span>;

    <span style="color: #408080; font-style: italic">/// Copy Constructor</span>
    basic_string_buffer(
        basic_string_buffer <span style="color: #008000; font-weight: bold">const</span><span style="color: #666666">&amp;</span>) <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">default</span>;

    <span style="color: #408080; font-style: italic">/// Copy Assignment</span>
    basic_string_buffer<span style="color: #666666">&amp;</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span>(
        basic_string_buffer <span style="color: #008000; font-weight: bold">const</span><span style="color: #666666">&amp;</span>) <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">default</span>;

    <span style="color: #408080; font-style: italic">/** Move Constructor</span>

<span style="color: #408080; font-style: italic">        After the move, the moved-from object will be as if default constructed.</span>

<span style="color: #408080; font-style: italic">        @par Exception Safety</span>

<span style="color: #408080; font-style: italic">        No-throw guarantee.</span>
<span style="color: #408080; font-style: italic">    */</span>
    basic_string_buffer(
        basic_string_buffer<span style="color: #666666">&amp;&amp;</span> other) noexcept
        <span style="color: #666666">:</span> s_(std<span style="color: #666666">::</span>move(other.s_))
        , max_(other.max_)
        , in_(boost<span style="color: #666666">::</span>exchange(other.in_, <span style="color: #666666">0</span>))
        , out_(boost<span style="color: #666666">::</span>exchange(other.out_, <span style="color: #666666">0</span>))
    {
    }

    <span style="color: #408080; font-style: italic">/** Move Assignment</span>

<span style="color: #408080; font-style: italic">        After the move, the moved-from object will be as if default constructed.</span>

<span style="color: #408080; font-style: italic">        @par Exception Safety</span>

<span style="color: #408080; font-style: italic">        No-throw guarantee.</span>
<span style="color: #408080; font-style: italic">    */</span>
    basic_string_buffer<span style="color: #666666">&amp;</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span>(
        basic_string_buffer<span style="color: #666666">&amp;&amp;</span> other) noexcept
    {
        s_   <span style="color: #666666">=</span> std<span style="color: #666666">::</span>move(other.s_);
        max_ <span style="color: #666666">=</span> other.max_;
        in_  <span style="color: #666666">=</span> boost<span style="color: #666666">::</span>exchange(other.in_, <span style="color: #666666">0</span>);
        out_ <span style="color: #666666">=</span> boost<span style="color: #666666">::</span>exchange(other.out_, <span style="color: #666666">0</span>);
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">*</span><span style="color: #008000; font-weight: bold">this</span>;
    }

    <span style="color: #408080; font-style: italic">/// Return the input area as a string view</span>
    string_view
    get() <span style="color: #008000; font-weight: bold">const</span> noexcept
    {
        <span style="color: #008000; font-weight: bold">return</span> { s_.data() <span style="color: #666666">+</span> in_, size() };
    }

    <span style="color: #408080; font-style: italic">/** Returns the internal string by transferring ownership to the caller.</span>

<span style="color: #408080; font-style: italic">        After the call, the internal string will be empty.</span>
<span style="color: #408080; font-style: italic">        All buffer sequences previously obtained using @ref prepare are</span>
<span style="color: #408080; font-style: italic">        invalidated. Buffer sequences previously obtained using @ref data</span>
<span style="color: #408080; font-style: italic">        remain valid.</span>
<span style="color: #408080; font-style: italic">    */</span>
    value_type
    release() noexcept
    {
        <span style="color: #008000; font-weight: bold">if</span>(in_ <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>)
        {
            BOOST_ASSERT(out_ <span style="color: #666666">!=</span> in_);
            std<span style="color: #666666">::</span>memmove(<span style="color: #666666">&amp;</span>s_[<span style="color: #666666">0</span>], <span style="color: #666666">&amp;</span>s_[in_], size());
        }
        s_.resize(size());
        in_ <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
        out_ <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
        <span style="color: #008000; font-weight: bold">return</span> std<span style="color: #666666">::</span>move(s_);
    }

    <span style="color: #408080; font-style: italic">/// Returns the number of readable bytes.</span>
    size_type
    size() <span style="color: #008000; font-weight: bold">const</span> noexcept
    {
        <span style="color: #008000; font-weight: bold">return</span> out_ <span style="color: #666666">-</span> in_;
    }

    <span style="color: #408080; font-style: italic">/// Return the maximum number of bytes, both readable and writable, that can ever be held.</span>
    size_type
    max_size() <span style="color: #008000; font-weight: bold">const</span> noexcept
    {
        <span style="color: #008000; font-weight: bold">return</span> max_;
    }

    <span style="color: #408080; font-style: italic">/** Set the maximum allowed total of readable and writable bytes.</span>

<span style="color: #408080; font-style: italic">        This function changes the currently configured upper limit</span>
<span style="color: #408080; font-style: italic">        on capacity to the specified value.</span>

<span style="color: #408080; font-style: italic">        @param n The maximum number of characters ever allowed for capacity.</span>

<span style="color: #408080; font-style: italic">        @par Exception Safety</span>

<span style="color: #408080; font-style: italic">        No-throw guarantee.</span>
<span style="color: #408080; font-style: italic">    */</span>
    <span style="color: #B00040">void</span>
    max_size(std<span style="color: #666666">::</span><span style="color: #B00040">size_t</span> n) noexcept
    {
        max_ <span style="color: #666666">=</span> n;
    }

    <span style="color: #408080; font-style: italic">/// Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation.</span>
    size_type
    capacity() <span style="color: #008000; font-weight: bold">const</span> noexcept
    {
        <span style="color: #008000; font-weight: bold">return</span> s_.capacity();
    }

    <span style="color: #408080; font-style: italic">/** Returns a constant buffer sequence representing the readable bytes</span>

<span style="color: #408080; font-style: italic">        @note The sequence may contain multiple contiguous memory regions.</span>
<span style="color: #408080; font-style: italic">    */</span>
    const_buffers_type
    data() <span style="color: #008000; font-weight: bold">const</span> noexcept
    {
        <span style="color: #008000; font-weight: bold">return</span> { s_.data() <span style="color: #666666">+</span> in_, size() };
    }

    <span style="color: #408080; font-style: italic">/** Returns a constant buffer sequence representing the readable bytes</span>

<span style="color: #408080; font-style: italic">        @note The sequence may contain multiple contiguous memory regions.</span>
<span style="color: #408080; font-style: italic">    */</span>
    const_buffers_type
    cdata() <span style="color: #008000; font-weight: bold">const</span> noexcept
    {
        <span style="color: #008000; font-weight: bold">return</span> { s_.data() <span style="color: #666666">+</span> in_, size() };
    }

    <span style="color: #408080; font-style: italic">/** Returns a mutable buffer sequence representing the readable bytes.</span>

<span style="color: #408080; font-style: italic">        @note The sequence may contain multiple contiguous memory regions.</span>
<span style="color: #408080; font-style: italic">    */</span>
    mutable_data_type
    data() noexcept
    {
        <span style="color: #008000; font-weight: bold">return</span> { <span style="color: #666666">&amp;</span>s_[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> in_, size() };
    }

    <span style="color: #408080; font-style: italic">/** Returns a mutable buffer sequence representing writable bytes.</span>
<span style="color: #408080; font-style: italic">    </span>
<span style="color: #408080; font-style: italic">        Returns a mutable buffer sequence representing the writable</span>
<span style="color: #408080; font-style: italic">        bytes containing exactly `n` bytes of storage. Memory may be</span>
<span style="color: #408080; font-style: italic">        reallocated as needed.</span>

<span style="color: #408080; font-style: italic">        All buffer sequences previously obtained using @ref prepare are</span>
<span style="color: #408080; font-style: italic">        invalidated. Buffer sequences previously obtained using @ref data</span>
<span style="color: #408080; font-style: italic">        remain valid.</span>

<span style="color: #408080; font-style: italic">        @param n The desired number of bytes in the returned buffer</span>
<span style="color: #408080; font-style: italic">        sequence.</span>

<span style="color: #408080; font-style: italic">        @throws std::length_error if `size() + n` exceeds `max_size()`.</span>

<span style="color: #408080; font-style: italic">        @par Exception Safety</span>

<span style="color: #408080; font-style: italic">        Strong guarantee.</span>
<span style="color: #408080; font-style: italic">    */</span>
    mutable_buffers_type
    prepare(size_type n)
    {
        <span style="color: #008000; font-weight: bold">auto</span> <span style="color: #008000; font-weight: bold">const</span> len <span style="color: #666666">=</span> size();
        <span style="color: #008000; font-weight: bold">if</span>(len <span style="color: #666666">&gt;</span> max_ <span style="color: #666666">||</span> n <span style="color: #666666">&gt;</span> (max_ <span style="color: #666666">-</span> len))
            BOOST_THROW_EXCEPTION(std<span style="color: #666666">::</span>length_error{
            <span style="color: #BA2121">&quot;basic_string_buffer overflow&quot;</span>});
        <span style="color: #008000; font-weight: bold">if</span>( out_ <span style="color: #666666">+</span> n <span style="color: #666666">&gt;</span> s_.capacity() <span style="color: #666666">&amp;&amp;</span>
            out_ <span style="color: #666666">+</span> n <span style="color: #666666">-</span> in_ <span style="color: #666666">&lt;=</span> s_.capacity())
        {
            std<span style="color: #666666">::</span>memmove(<span style="color: #666666">&amp;</span>s_[<span style="color: #666666">0</span>], <span style="color: #666666">&amp;</span>s_[in_], size());
            out_ <span style="color: #666666">-=</span> in_;
            in_ <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
        }
        s_.resize(out_ <span style="color: #666666">+</span> n);
        <span style="color: #008000; font-weight: bold">return</span> { <span style="color: #666666">&amp;</span>s_[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> out_, n };
    }

    <span style="color: #408080; font-style: italic">/** Append writable bytes to the readable bytes.</span>

<span style="color: #408080; font-style: italic">        Appends n bytes from the start of the writable bytes to the</span>
<span style="color: #408080; font-style: italic">        end of the readable bytes. The remainder of the writable bytes</span>
<span style="color: #408080; font-style: italic">        are discarded. If n is greater than the number of writable</span>
<span style="color: #408080; font-style: italic">        bytes, all writable bytes are appended to the readable bytes.</span>

<span style="color: #408080; font-style: italic">        All buffer sequences previously obtained using @ref prepare are</span>
<span style="color: #408080; font-style: italic">        invalidated. Buffer sequences previously obtained using @ref data</span>
<span style="color: #408080; font-style: italic">        remain valid.</span>

<span style="color: #408080; font-style: italic">        @param n The number of bytes to append. If this number</span>
<span style="color: #408080; font-style: italic">        is greater than the number of writable bytes, all</span>
<span style="color: #408080; font-style: italic">        writable bytes are appended.</span>

<span style="color: #408080; font-style: italic">        @par Exception Safety</span>

<span style="color: #408080; font-style: italic">        No-throw guarantee.</span>
<span style="color: #408080; font-style: italic">    */</span>
    <span style="color: #B00040">void</span>
    commit(size_type n) noexcept
    {
        <span style="color: #008000; font-weight: bold">if</span>(n <span style="color: #666666">&gt;=</span> s_.size() <span style="color: #666666">-</span> out_)
            out_ <span style="color: #666666">=</span> s_.size();
        <span style="color: #008000; font-weight: bold">else</span>
            out_ <span style="color: #666666">+=</span> n;
    }

    <span style="color: #408080; font-style: italic">/** Remove bytes from beginning of the readable bytes.</span>

<span style="color: #408080; font-style: italic">        Removes n bytes from the beginning of the readable bytes.</span>

<span style="color: #408080; font-style: italic">        All buffers sequences previously obtained using</span>
<span style="color: #408080; font-style: italic">        @ref data or @ref prepare are invalidated.</span>

<span style="color: #408080; font-style: italic">        @param n The number of bytes to remove. If this number</span>
<span style="color: #408080; font-style: italic">        is greater than the number of readable bytes, all</span>
<span style="color: #408080; font-style: italic">        readable bytes are removed.</span>

<span style="color: #408080; font-style: italic">        @par Exception Safety</span>

<span style="color: #408080; font-style: italic">        No-throw guarantee.</span>
<span style="color: #408080; font-style: italic">    */</span>
    <span style="color: #B00040">void</span>
    consume(size_type n) noexcept
    {
        <span style="color: #008000; font-weight: bold">if</span>(in_ <span style="color: #666666">+</span> n <span style="color: #666666">&lt;</span> out_)
        {
            in_ <span style="color: #666666">+=</span> n;
        }
        <span style="color: #008000; font-weight: bold">else</span>
        {
            in_ <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
            out_ <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
        }
    }
};

<span style="color: #408080; font-style: italic">/// A dynamic string buffer of char</span>
<span style="color: #008000; font-weight: bold">using</span> string_buffer <span style="color: #666666">=</span> basic_string_buffer<span style="color: #666666">&lt;</span><span style="color: #B00040">char</span><span style="color: #666666">&gt;</span>;

<span style="color: #408080; font-style: italic">/// A dynamic string buffer of wchar_t</span>
<span style="color: #008000; font-weight: bold">using</span> wstring_buffer <span style="color: #666666">=</span> basic_string_buffer<span style="color: #666666">&lt;</span><span style="color: #B00040">wchar_t</span><span style="color: #666666">&gt;</span>;
</pre></td></tr></table></div>

</body>
</html>
