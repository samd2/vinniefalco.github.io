<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Layered Streams</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Boost.Beast">
<link rel="up" href="../using_io.html" title="Using Networking">
<link rel="prev" href="stream_types.html" title="Stream Types">
<link rel="next" href="buffer_types.html" title="Buffer Types">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="stream_types.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../using_io.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="buffer_types.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="beast.using_io.layered_streams"></a><a class="link" href="layered_streams.html" title="Layered Streams">Layered Streams</a>
</h3></div></div></div>
<p>
        Networking's <a href="../../../../../../doc/html/boost_asio/reference/ssl__stream.html" target="_top"><code class="computeroutput"><span class="identifier">net</span><span class="special">::</span><span class="identifier">ssl</span><span class="special">::</span><span class="identifier">stream</span></code></a>
        is a class template meeting the requirements of both synchronous and asynchronous
        read and write streams, implemented in terms of a "next layer"
        object whose type is determined by a class template parameter. The SSL stream
        constructs an instance of the next layer object internally, while allowing
        external access through the observer <code class="computeroutput"><span class="identifier">net</span><span class="special">::</span><span class="identifier">ssl</span><span class="special">::</span><span class="identifier">stream</span><span class="special">::</span><span class="identifier">next_layer</span><span class="special">()</span></code>.
        This declares an SSL stream which uses a regular TCP/IP socket as the next
        layer:
      </p>
<pre class="programlisting"><span class="identifier">net</span><span class="special">::</span><span class="identifier">ssl</span><span class="special">::</span><span class="identifier">stream</span><span class="special">&lt;</span><span class="identifier">net</span><span class="special">::</span><span class="identifier">ip</span><span class="special">::</span><span class="identifier">tcp</span><span class="special">::</span><span class="identifier">socket</span><span class="special">&gt;</span> <span class="identifier">ss</span><span class="special">(</span><span class="identifier">ioc</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
</pre>
<p>
        Objects using this design pattern are referred to in networking as "a
        stack of stream layers". In Beast we use the term <span class="emphasis"><em>layered
        stream</em></span>, although the property of having a next layer is not exclusive
        to streams. As with the SSL stream, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">websocket</span><span class="special">::</span><span class="identifier">stream</span></code></a> is a class template parameterized
        on a next layer object. This declares a websocket stream which uses a regular
        TCP/IP socket as the next layer:
      </p>
<pre class="programlisting"><span class="identifier">websocket</span><span class="special">::</span><span class="identifier">stream</span><span class="special">&lt;</span><span class="identifier">net</span><span class="special">::</span><span class="identifier">ip</span><span class="special">::</span><span class="identifier">tcp</span><span class="special">::</span><span class="identifier">socket</span><span class="special">&gt;</span> <span class="identifier">ws</span><span class="special">(</span><span class="identifier">ioc</span><span class="special">);</span>
</pre>
<p>
        If a Secure WebSockets stream is desired, this is accomplished simply by
        changing the type of the next layer and adjusting the constructor arguments
        to match:
      </p>
<pre class="programlisting"><span class="identifier">websocket</span><span class="special">::</span><span class="identifier">stream</span><span class="special">&lt;</span><span class="identifier">net</span><span class="special">::</span><span class="identifier">ssl</span><span class="special">::</span><span class="identifier">stream</span><span class="special">&lt;</span><span class="identifier">net</span><span class="special">::</span><span class="identifier">ip</span><span class="special">::</span><span class="identifier">tcp</span><span class="special">::</span><span class="identifier">socket</span><span class="special">&gt;&gt;</span> <span class="identifier">ws</span><span class="special">(</span><span class="identifier">ioc</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
</pre>
<p>
        Higher level abstractions can be developed in this fashion by nesting stream
        layers to arbitrary degree. The stack of stream layers effectively forms
        a compile-time singly linked list. The object at the end of this list is
        called the <span class="emphasis"><em>lowest layer</em></span>, and is special from the others
        because it typically represents the underlying socket.
      </p>
<p>
        Beast comes with several layered stream wrappers, as well as facilities for
        authoring and working with layered streams:
      </p>
<div class="table">
<a name="beast.using_io.layered_streams.layered_stream_algorithms_and_ty"></a><p class="title"><b>Table&#160;1.5.&#160;Layered Stream Algorithms and Types</b></p>
<div class="table-contents"><table class="table" summary="Layered Stream Algorithms and Types">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Name
                </p>
              </th>
<th>
                <p>
                  Description
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <a class="link" href="../../"><code class="computeroutput"><span class="identifier">timeout_stream</span></code></a> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">basic_timeout_stream</span></code></a>
                </p>
              </td>
<td>
                <p>
                  A timeout stream meets the requirements for synchronous and asynchronous
                  read and write streams, and additionally provides configurable
                  timeouts for logical operations that include reading, writing,
                  and/or connecting.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../../"><code class="computeroutput"><span class="identifier">buffered_read_stream</span></code></a>
                </p>
              </td>
<td>
                <p>
                  A timeout stream meets the requirements for synchronous and asynchronous
                  read and write streams, and additionally implements configurable
                  buffering for reads.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../../"><code class="computeroutput"><span class="identifier">close_socket</span></code></a>
                </p>
              </td>
<td>
                <p>
                  This function closes a socket by performing an unqualified call
                  to the <a class="link" href="../../"><code class="computeroutput"><span class="identifier">beast_close_socket</span></code></a> customization
                  point, allowing sockets to be closed in generic contexts in an
                  extensible fashion.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../../"><code class="computeroutput"><span class="identifier">flat_stream</span></code></a>
                </p>
              </td>
<td>
                <p>
                  A flat stream operates as a transparent stream which helps to work
                  around a limitation of <code class="computeroutput"><span class="identifier">net</span><span class="special">::</span><span class="identifier">ssl</span><span class="special">::</span><span class="identifier">stream</span></code>.
                  It is used in the implementation of <a class="link" href="../../"><code class="computeroutput"><span class="identifier">ssl_stream</span></code></a>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../../"><code class="computeroutput"><span class="identifier">get_lowest_layer</span></code></a>
                </p>
              </td>
<td>
                <p>
                  Returns the lowest layer in a stack of stream layers by recursively
                  calling the <code class="computeroutput"><span class="identifier">next_layer</span></code>
                  member function on each object until reaching an object which lacks
                  the member. This example puts a layered stream into non-blocking
                  mode by retrieving the TCP/IP socket in the lowest layer and changing
                  the socket option:
                </p>
<pre class="programlisting"><span class="comment">// Set non-blocking mode on a stack of stream</span>
<span class="comment">// layers with a regular socket at the lowest layer.</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Stream</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">set_non_blocking</span> <span class="special">(</span><span class="identifier">Stream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">;</span>
    <span class="comment">// A compile error here means your lowest layer is not the right type!</span>
    <span class="identifier">get_lowest_layer</span><span class="special">(</span><span class="identifier">stream</span><span class="special">).</span><span class="identifier">non_blocking</span><span class="special">(</span><span class="keyword">true</span><span class="special">,</span> <span class="identifier">ec</span><span class="special">);</span>
    <span class="keyword">if</span><span class="special">(</span><span class="identifier">ec</span><span class="special">)</span>
        <span class="keyword">throw</span> <span class="identifier">system_error</span><span class="special">{</span><span class="identifier">ec</span><span class="special">};</span>
<span class="special">}</span>
</pre>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../../"><code class="computeroutput"><span class="identifier">http</span><span class="special">::</span><span class="identifier">icy_stream</span></code></a>
                </p>
              </td>
<td>
                <p>
                  An ICY stream transparently converts the non-standard "ICY
                  200 OK" HTTP response from Shoutcast servers into a conforming
                  200 level HTTP response.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../../"><code class="computeroutput"><span class="identifier">lowest_layer_type</span></code></a>
                </p>
              </td>
<td>
                <p>
                  A metafunction to return the type of the lowest layer used in a
                  type representing a stack of stream layers. This is the type of
                  reference returned by <a class="link" href="../../"><code class="computeroutput"><span class="identifier">get_lowest_layer</span></code></a>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../../"><code class="computeroutput"><span class="identifier">ssl_stream</span></code></a>
                </p>
              </td>
<td>
                <p>
                  The SSL stream is a drop-in replacement for <code class="computeroutput"><span class="identifier">net</span><span class="special">::</span><span class="identifier">ssl</span><span class="special">::</span><span class="identifier">stream</span></code>
                  which allows for move-construction and move-assignment, and also
                  implements a work-around for a performance limitation in the original
                  SSL stream.
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><h5>
<a name="beast.using_io.layered_streams.h0"></a>
        <span class="phrase"><a name="beast.using_io.layered_streams.example"></a></span><a class="link" href="layered_streams.html#beast.using_io.layered_streams.example">Example</a>
      </h5>
<p>
        This example shows the definition of a layered stream which keeps individual
        counts of the total number of bytes read from and written to the next layer.
        It meets the requirements for synchronous and asynchronous read and write
        streams:
      </p>
<pre class="programlisting"><span class="comment">// A layered stream which counts the bytes read and bytes written on the next layer</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">NextLayer</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">counted_stream</span>
<span class="special">{</span>
    <span class="identifier">NextLayer</span> <span class="identifier">next_layer_</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bytes_read_</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bytes_written_</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">/// The type of executor used by this stream</span>
    <span class="keyword">using</span> <span class="identifier">executor_type</span> <span class="special">=</span> <span class="identifier">detail</span><span class="special">::</span><span class="identifier">get_executor_type</span><span class="special">&lt;</span><span class="identifier">NextLayer</span><span class="special">&gt;;</span>

    <span class="comment">/// Constructor</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span><span class="special">...</span> <span class="identifier">Args</span><span class="special">&gt;</span>
    <span class="keyword">explicit</span>
    <span class="identifier">counted_stream</span><span class="special">(</span><span class="identifier">Args</span><span class="special">&amp;&amp;...</span> <span class="identifier">args</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">next_layer_</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">)...)</span>
    <span class="special">{</span>
    <span class="special">}</span>

    <span class="comment">/// Returns an instance of the executor used to submit completion handlers</span>
    <span class="identifier">executor_type</span> <span class="identifier">get_executor</span><span class="special">()</span> <span class="keyword">noexcept</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">next_layer_</span><span class="special">.</span><span class="identifier">get_executor</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="comment">/// Returns a reference to the next layer</span>
    <span class="identifier">NextLayer</span><span class="special">&amp;</span> <span class="identifier">next_layer</span><span class="special">()</span> <span class="keyword">noexcept</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">next_layer_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">/// Returns a reference to the next layer</span>
    <span class="identifier">NextLayer</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">next_layer</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">next_layer_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">/// Returns the total number of bytes read since the stream was constructed</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bytes_read</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">bytes_read_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">/// Returns the total number of bytes written since the stream was constructed</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bytes_written</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">bytes_written_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">/// Read some data from the stream</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">MutableBufferSequence</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">read_some</span><span class="special">(</span><span class="identifier">MutableBufferSequence</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">buffers</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">bytes_transferred</span> <span class="special">=</span> <span class="identifier">next_layer_</span><span class="special">.</span><span class="identifier">read_some</span><span class="special">(</span><span class="identifier">buffers</span><span class="special">);</span>
        <span class="identifier">bytes_read_</span> <span class="special">+=</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">/// Read some data from the stream</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">MutableBufferSequence</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">read_some</span><span class="special">(</span><span class="identifier">MutableBufferSequence</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">buffers</span><span class="special">,</span> <span class="identifier">error_code</span><span class="special">&amp;</span> <span class="identifier">ec</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">bytes_transferred</span> <span class="special">=</span> <span class="identifier">next_layer_</span><span class="special">.</span><span class="identifier">read_some</span><span class="special">(</span><span class="identifier">buffers</span><span class="special">,</span> <span class="identifier">ec</span><span class="special">);</span>
        <span class="identifier">bytes_read_</span> <span class="special">+=</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">/// Write some data to the stream</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ConstBufferSequence</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">write_some</span><span class="special">(</span><span class="identifier">ConstBufferSequence</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">buffers</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">bytes_transferred</span> <span class="special">=</span> <span class="identifier">next_layer_</span><span class="special">.</span><span class="identifier">write_some</span><span class="special">(</span><span class="identifier">buffers</span><span class="special">);</span>
        <span class="identifier">bytes_written_</span> <span class="special">+=</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">/// Write some data to the stream</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ConstBufferSequence</span><span class="special">&gt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">write_some</span><span class="special">(</span><span class="identifier">ConstBufferSequence</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">buffers</span><span class="special">,</span> <span class="identifier">error_code</span><span class="special">&amp;</span> <span class="identifier">ec</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">bytes_transferred</span> <span class="special">=</span> <span class="identifier">next_layer_</span><span class="special">.</span><span class="identifier">write_some</span><span class="special">(</span><span class="identifier">buffers</span><span class="special">,</span> <span class="identifier">ec</span><span class="special">);</span>
        <span class="identifier">bytes_written_</span> <span class="special">+=</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">/// Read some data from the stream asynchronously</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">MutableBufferSequence</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">ReadHandler</span><span class="special">&gt;</span>
    <span class="identifier">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="special">(</span><span class="identifier">ReadHandler</span><span class="special">,</span>
        <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">))</span>
    <span class="identifier">async_read_some</span><span class="special">(</span>
        <span class="identifier">MutableBufferSequence</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">buffers</span><span class="special">,</span>
        <span class="identifier">ReadHandler</span><span class="special">&amp;&amp;</span> <span class="identifier">handler</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">handler_type</span> <span class="special">=</span> <span class="identifier">BOOST_ASIO_HANDLER_TYPE</span><span class="special">(</span>
            <span class="identifier">ReadHandler</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">));</span>
        <span class="keyword">struct</span> <span class="identifier">op</span> <span class="special">:</span> <span class="identifier">async_op_base</span><span class="special">&lt;</span><span class="identifier">handler_type</span><span class="special">,</span> <span class="identifier">executor_type</span><span class="special">&gt;</span>
        <span class="special">{</span>
            <span class="identifier">counted_stream</span><span class="special">&amp;</span> <span class="identifier">stream_</span><span class="special">;</span>

            <span class="identifier">op</span><span class="special">(</span>
                <span class="identifier">counted_stream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span>
                <span class="identifier">handler_type</span><span class="special">&amp;&amp;</span> <span class="identifier">handler</span><span class="special">,</span>
                <span class="identifier">MutableBufferSequence</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">buffers</span><span class="special">)</span>
                <span class="special">:</span> <span class="identifier">async_op_base</span><span class="special">&lt;</span><span class="identifier">handler_type</span><span class="special">,</span> <span class="identifier">executor_type</span><span class="special">&gt;(</span>
                    <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">handler</span><span class="special">),</span> <span class="identifier">stream</span><span class="special">.</span><span class="identifier">get_executor</span><span class="special">())</span>
                <span class="special">,</span> <span class="identifier">stream_</span><span class="special">(</span><span class="identifier">stream</span><span class="special">)</span>
            <span class="special">{</span>
                <span class="identifier">stream_</span><span class="special">.</span><span class="identifier">next_layer</span><span class="special">().</span><span class="identifier">async_read_some</span><span class="special">(</span><span class="identifier">buffers</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span>
            <span class="special">}</span>

            <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bytes_transferred</span><span class="special">)</span>
            <span class="special">{</span>
                <span class="identifier">stream_</span><span class="special">.</span><span class="identifier">bytes_read_</span> <span class="special">+=</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
                <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">invoke</span><span class="special">(</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">bytes_transferred</span><span class="special">);</span>
            <span class="special">}</span>
        <span class="special">};</span>
        <span class="identifier">net</span><span class="special">::</span><span class="identifier">async_completion</span><span class="special">&lt;</span><span class="identifier">ReadHandler</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">)&gt;</span> <span class="identifier">init</span><span class="special">{</span><span class="identifier">handler</span><span class="special">};</span>
        <span class="identifier">op</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">init</span><span class="special">.</span><span class="identifier">completion_handler</span><span class="special">),</span> <span class="identifier">buffers</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">init</span><span class="special">.</span><span class="identifier">result</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="comment">/// Write some data to the stream asynchronously</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ConstBufferSequence</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">WriteHandler</span><span class="special">&gt;</span>
    <span class="identifier">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="special">(</span><span class="identifier">WriteHandler</span><span class="special">,</span>
        <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">))</span>
    <span class="identifier">async_write_some</span><span class="special">(</span>
        <span class="identifier">ConstBufferSequence</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">buffers</span><span class="special">,</span>
        <span class="identifier">WriteHandler</span><span class="special">&amp;&amp;</span> <span class="identifier">handler</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">handler_type</span> <span class="special">=</span> <span class="identifier">BOOST_ASIO_HANDLER_TYPE</span><span class="special">(</span>
            <span class="identifier">WriteHandler</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">));</span>
        <span class="keyword">struct</span> <span class="identifier">op</span> <span class="special">:</span> <span class="identifier">async_op_base</span><span class="special">&lt;</span><span class="identifier">handler_type</span><span class="special">,</span> <span class="identifier">executor_type</span><span class="special">&gt;</span>
        <span class="special">{</span>
            <span class="identifier">counted_stream</span><span class="special">&amp;</span> <span class="identifier">stream_</span><span class="special">;</span>

            <span class="identifier">op</span><span class="special">(</span> <span class="identifier">counted_stream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span>
                <span class="identifier">handler_type</span><span class="special">&amp;&amp;</span> <span class="identifier">handler</span><span class="special">,</span>
                <span class="identifier">ConstBufferSequence</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">buffers</span><span class="special">)</span>
                <span class="special">:</span> <span class="identifier">async_op_base</span><span class="special">&lt;</span><span class="identifier">handler_type</span><span class="special">,</span> <span class="identifier">executor_type</span><span class="special">&gt;(</span>
                    <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">handler</span><span class="special">),</span> <span class="identifier">stream</span><span class="special">.</span><span class="identifier">get_executor</span><span class="special">())</span>
                <span class="special">,</span> <span class="identifier">stream_</span><span class="special">(</span><span class="identifier">stream</span><span class="special">)</span>
            <span class="special">{</span>
                <span class="identifier">stream_</span><span class="special">.</span><span class="identifier">next_layer</span><span class="special">().</span><span class="identifier">async_write_some</span><span class="special">(</span><span class="identifier">buffers</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span>
            <span class="special">}</span>

            <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bytes_transferred</span><span class="special">)</span>
            <span class="special">{</span>
                <span class="identifier">stream_</span><span class="special">.</span><span class="identifier">bytes_written_</span> <span class="special">+=</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
                <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">invoke</span><span class="special">(</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">bytes_transferred</span><span class="special">);</span>
            <span class="special">}</span>
        <span class="special">};</span>
        <span class="identifier">net</span><span class="special">::</span><span class="identifier">async_completion</span><span class="special">&lt;</span><span class="identifier">WriteHandler</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">)&gt;</span> <span class="identifier">init</span><span class="special">{</span><span class="identifier">handler</span><span class="special">};</span>
        <span class="identifier">op</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">init</span><span class="special">.</span><span class="identifier">completion_handler</span><span class="special">),</span> <span class="identifier">buffers</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">init</span><span class="special">.</span><span class="identifier">result</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016, 2017 Vinnie Falco<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="stream_types.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../using_io.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="buffer_types.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
