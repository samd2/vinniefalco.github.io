<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>async_op_base</title>
<link rel="stylesheet" href="../../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../../index.html" title="Chapter&#160;1.&#160;Boost.Beast">
<link rel="up" href="../ref.html" title="This Page Intentionally Left Blank 2/2">
<link rel="prev" href="boost__beast__async_connect/overload4.html" title="async_connect (4 of 4 overloads)">
<link rel="next" href="boost__beast__async_op_base/allocator_type.html" title="async_op_base::allocator_type">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="boost__beast__async_connect/overload4.html"><img src="../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../ref.html"><img src="../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="boost__beast__async_op_base/allocator_type.html"><img src="../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="beast.using_io.ref.boost__beast__async_op_base"></a><a class="link" href="boost__beast__async_op_base.html" title="async_op_base">async_op_base</a>
</h5></div></div></div>
<p>
          Base class to provide completion handler boilerplate for composed operations.
        </p>
<h6>
<a name="beast.using_io.ref.boost__beast__async_op_base.h0"></a>
          <span class="phrase"><a name="beast.using_io.ref.boost__beast__async_op_base.synopsis"></a></span><a class="link" href="boost__beast__async_op_base.html#beast.using_io.ref.boost__beast__async_op_base.synopsis">Synopsis</a>
        </h6>
<p>
          Defined in header <code class="literal">&lt;<a href="../../../../../../../boost/beast/core/async_op_base.hpp" target="_top">boost/beast/core/async_op_base.hpp</a>&gt;</code>
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">class</span> <a href="../../../../../../../doc/html/boost_asio/reference/Handler.html" target="_top"><span class="bold"><strong>Handler</strong></span></a><span class="special">,</span>
    <span class="keyword">class</span> <span class="identifier">Executor1</span><span class="special">,</span>
    <span class="keyword">class</span> <span class="identifier">Allocator</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;&gt;</span>
<span class="keyword">class</span> <span class="identifier">async_op_base</span>
</pre>
<h6>
<a name="beast.using_io.ref.boost__beast__async_op_base.h1"></a>
          <span class="phrase"><a name="beast.using_io.ref.boost__beast__async_op_base.types"></a></span><a class="link" href="boost__beast__async_op_base.html#beast.using_io.ref.boost__beast__async_op_base.types">Types</a>
        </h6>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Name
                  </p>
                </th>
<th>
                  <p>
                    Description
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    <a class="link" href="../../../"><span class="bold"><strong>allocator_type</strong></span></a>
                  </p>
                </td>
<td>
                  <p>
                    The type of allocator associated with this object.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <a class="link" href="../../../"><span class="bold"><strong>executor_type</strong></span></a>
                  </p>
                </td>
<td>
                  <p>
                    The type of executor associated with this object.
                  </p>
                </td>
</tr>
</tbody>
</table></div>
<h6>
<a name="beast.using_io.ref.boost__beast__async_op_base.h2"></a>
          <span class="phrase"><a name="beast.using_io.ref.boost__beast__async_op_base.member_functions"></a></span><a class="link" href="boost__beast__async_op_base.html#beast.using_io.ref.boost__beast__async_op_base.member_functions">Member
          Functions</a>
        </h6>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Name
                  </p>
                </th>
<th>
                  <p>
                    Description
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    <a class="link" href="../../../"><span class="bold"><strong>async_op_base</strong></span></a>
                  </p>
                </td>
<td>
                  <p>
                    Constructor.
                  </p>
                  <p>
                    Move Constructor.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <a class="link" href="../../../"><span class="bold"><strong>get_allocator</strong></span></a>
                  </p>
                </td>
<td>
                  <p>
                    Returns the allocator associated with this object.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <a class="link" href="../../../"><span class="bold"><strong>get_executor</strong></span></a>
                  </p>
                </td>
<td>
                  <p>
                    Returns the executor associated with this object.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <a class="link" href="../../../"><span class="bold"><strong>handler</strong></span></a>
                  </p>
                </td>
<td>
                  <p>
                    Returns the handler associated with this object.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <a class="link" href="../../../"><span class="bold"><strong>invoke</strong></span></a>
                  </p>
                </td>
<td>
                  <p>
                    Invoke the final completion handler.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <a class="link" href="../../../"><span class="bold"><strong>release_handler</strong></span></a>
                  </p>
                </td>
<td>
                  <p>
                    Returns ownership of the handler associated with this object.
                  </p>
                </td>
</tr>
</tbody>
</table></div>
<h6>
<a name="beast.using_io.ref.boost__beast__async_op_base.h3"></a>
          <span class="phrase"><a name="beast.using_io.ref.boost__beast__async_op_base.description"></a></span><a class="link" href="boost__beast__async_op_base.html#beast.using_io.ref.boost__beast__async_op_base.description">Description</a>
        </h6>
<p>
          A function object submitted to intermediate initiating functions during
          a composed operation may derive from this type to inherit all of the boilerplate
          to forward the executor, allocator, and legacy customization points associated
          with the completion handler invoked at the end of the composed operation.
        </p>
<p>
          The composed operation must be typical; that is, associated with one executor
          of an I/O object, and invoking a caller-provided completion handler when
          the operation is finished. Classes derived from <a class="link" href="../../../"><code class="computeroutput"><span class="identifier">async_op_base</span></code></a> will acquire these
          properties:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              Ownership of the final completion handler provided upon construction.
            </li>
<li class="listitem">
              If the final handler has an associated allocator, this allocator will
              be propagated to the composed operation subclass. Otherwise, the associated
              allocator will be the type specified in the allocator template parameter,
              or the default of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code> if the parameter is omitted.
            </li>
<li class="listitem">
              If the final handler has an associated executor, then it will be used
              as the executor associated with the composed operation. Otherwise,
              the specified <code class="computeroutput"><span class="identifier">Executor1</span></code>
              will be the type of executor associated with the composed operation.
            </li>
<li class="listitem">
              An instance of <code class="computeroutput"><span class="identifier">net</span><span class="special">::</span><span class="identifier">executor_work_guard</span></code>
              for the instance of <code class="computeroutput"><span class="identifier">Executor1</span></code>
              shall be maintained until either the final handler is invoked, or the
              operation base is destroyed, whichever comes first.
            </li>
<li class="listitem">
              Calls to the legacy customization points <code class="computeroutput"><span class="identifier">asio_handler_invoke</span></code>,
              <code class="computeroutput"><span class="identifier">asio_handler_allocate</span></code>,
              <code class="computeroutput"><span class="identifier">asio_handler_deallocate</span></code>,
              and <code class="computeroutput"><span class="identifier">asio_handler_is_continuation</span></code>,
              which use argument-dependent lookup, will be forwarded to the legacy
              customization points associated with the handler.
            </li>
</ul></div>
<h6>
<a name="beast.using_io.ref.boost__beast__async_op_base.h4"></a>
          <span class="phrase"><a name="beast.using_io.ref.boost__beast__async_op_base.example"></a></span><a class="link" href="boost__beast__async_op_base.html#beast.using_io.ref.boost__beast__async_op_base.example">Example</a>
        </h6>
<p>
          The following code demonstrates how <a class="link" href="../../../"><code class="computeroutput"><span class="identifier">async_op_base</span></code></a> may be be used to
          assist authoring an asynchronous initiating function, by providing all
          of the boilerplate to manage the final completion handler in a way that
          maintains the allocator and executor associations:
        </p>
<pre class="programlisting"><span class="comment">// Asynchronously read into a buffer until the buffer is full, or an error occurs</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncReadStream</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">ReadHandler</span><span class="special">&gt;</span>
<span class="identifier">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="special">(</span><span class="identifier">ReadHandler</span><span class="special">,</span> <span class="keyword">void</span> <span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">))</span>
<span class="identifier">async_read</span><span class="special">(</span><span class="identifier">AsyncReadStream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="identifier">net</span><span class="special">::</span><span class="identifier">mutable_buffer</span> <span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">ReadHandler</span><span class="special">&amp;&amp;</span> <span class="identifier">handler</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">handler_type</span> <span class="special">=</span> <span class="identifier">BOOST_ASIO_HANDLER_TYPE</span><span class="special">(</span><span class="identifier">ReadHandler</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">));</span>
    <span class="keyword">using</span> <span class="identifier">base_type</span> <span class="special">=</span> <span class="identifier">async_op_base</span><span class="special">&lt;</span><span class="identifier">handler_type</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">AsyncReadStream</span><span class="special">::</span><span class="identifier">executor_type</span><span class="special">&gt;;</span>

    <span class="keyword">struct</span> <span class="identifier">read_op</span> <span class="special">:</span> <span class="identifier">base_type</span>
    <span class="special">{</span>
        <span class="identifier">AsyncReadStream</span><span class="special">&amp;</span> <span class="identifier">stream_</span><span class="special">;</span>
        <span class="identifier">net</span><span class="special">::</span><span class="identifier">mutable_buffer</span> <span class="identifier">buffer_</span><span class="special">;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">total_bytes_transferred_</span><span class="special">;</span>

        <span class="identifier">read_op</span><span class="special">(</span>
            <span class="identifier">AsyncReadStream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span>
            <span class="identifier">net</span><span class="special">::</span><span class="identifier">mutable_buffer</span> <span class="identifier">buffer</span><span class="special">,</span>
            <span class="identifier">handler_type</span><span class="special">&amp;</span> <span class="identifier">handler</span><span class="special">)</span>
            <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span><span class="identifier">stream</span><span class="special">.</span><span class="identifier">get_executor</span><span class="special">(),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">handler</span><span class="special">))</span>
            <span class="special">,</span> <span class="identifier">stream_</span><span class="special">(</span><span class="identifier">stream</span><span class="special">)</span>
            <span class="special">,</span> <span class="identifier">buffer_</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">)</span>
            <span class="special">,</span> <span class="identifier">total_bytes_transferred_</span><span class="special">(</span><span class="number">0</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="special">(*</span><span class="keyword">this</span><span class="special">)({},</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">false</span><span class="special">);</span> <span class="comment">// start the operation</span>
        <span class="special">}</span>

        <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bytes_transferred</span><span class="special">,</span> <span class="keyword">bool</span> <span class="identifier">is_continuation</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="comment">// Adjust the count of bytes and advance our buffer</span>
            <span class="identifier">total_bytes_transferred_</span> <span class="special">+=</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
            <span class="identifier">buffer_</span> <span class="special">=</span> <span class="identifier">buffer_</span> <span class="special">+</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>

            <span class="comment">// Keep reading until buffer is full or an error occurs</span>
            <span class="keyword">if</span><span class="special">(!</span> <span class="identifier">ec</span> <span class="special">&amp;&amp;</span> <span class="identifier">buffer_</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">)</span>
                <span class="keyword">return</span> <span class="identifier">stream_</span><span class="special">.</span><span class="identifier">async_read_some</span><span class="special">(</span><span class="identifier">buffer_</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span>

            <span class="comment">// If this is first invocation, we have to post to the executor. Otherwise the</span>
            <span class="comment">// handler would be invoked before the call to async_read returns, which is disallowed.</span>
            <span class="keyword">if</span><span class="special">(!</span> <span class="identifier">is_continuation</span><span class="special">)</span>
            <span class="special">{</span>
                <span class="comment">// Issue a zero-sized read so our handler runs "as-if" posted using net::post().</span>
                <span class="comment">// This technique is used to reduce the number of function template instantiations.</span>
                <span class="keyword">return</span> <span class="identifier">stream_</span><span class="special">.</span><span class="identifier">async_read_some</span><span class="special">(</span><span class="identifier">net</span><span class="special">::</span><span class="identifier">mutable_buffer</span><span class="special">(</span><span class="identifier">buffer_</span><span class="special">.</span><span class="identifier">data</span><span class="special">(),</span> <span class="number">0</span><span class="special">),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span>
            <span class="special">}</span>

            <span class="comment">// Call the completion handler with the result</span>
            <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">invoke</span><span class="special">(</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">total_bytes_transferred_</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="identifier">net</span><span class="special">::</span><span class="identifier">async_completion</span><span class="special">&lt;</span><span class="identifier">ReadHandler</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">)&gt;</span> <span class="identifier">init</span><span class="special">{</span><span class="identifier">handler</span><span class="special">};</span>
    <span class="identifier">read_op</span><span class="special">(</span><span class="identifier">stream</span><span class="special">,</span> <span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">init</span><span class="special">.</span><span class="identifier">completion_handler</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="identifier">init</span><span class="special">.</span><span class="identifier">result</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
          Data members of composed operations implemented as completion handlers
          do not have stable addresses, as the composed operation object is move
          constructed upon each call to an initiating function. For most operations
          this is not a problem. For complex operations requiring stable temporary
          storage, the class <a class="link" href="../../../"><code class="computeroutput"><span class="identifier">stable_async_op_base</span></code></a> is provided
          which offers additional functionality:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              The free function <a class="link" href="../../../"><code class="computeroutput"><span class="identifier">allocate_stable</span></code></a> may be used
              to allocate one or more temporary objects associated with the composed
              operation.
            </li>
<li class="listitem">
              Memory for stable temporary objects is allocated using the allocator
              associated with the composed operation.
            </li>
<li class="listitem">
              Stable temporary objects are automatically destroyed, and the memory
              freed using the associated allocator, either before the final completion
              handler is invoked (a Networking requirement) or when the composed
              operation is destroyed, whichever occurs first.
            </li>
</ul></div>
<h6>
<a name="beast.using_io.ref.boost__beast__async_op_base.h5"></a>
          <span class="phrase"><a name="beast.using_io.ref.boost__beast__async_op_base.temporary_storage_example"></a></span><a class="link" href="boost__beast__async_op_base.html#beast.using_io.ref.boost__beast__async_op_base.temporary_storage_example">Temporary
          Storage Example</a>
        </h6>
<p>
          The following example demonstrates how a composed operation may store a
          temporary object.
        </p>
<h6>
<a name="beast.using_io.ref.boost__beast__async_op_base.h6"></a>
          <span class="phrase"><a name="beast.using_io.ref.boost__beast__async_op_base.template_parameters"></a></span><a class="link" href="boost__beast__async_op_base.html#beast.using_io.ref.boost__beast__async_op_base.template_parameters">Template
          Parameters</a>
        </h6>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Type
                  </p>
                </th>
<th>
                  <p>
                    Description
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">Handler</span></code>
                  </p>
                </td>
<td>
                  <p>
                    The type of the completion handler to store. This type must meet
                    the requirements of CompletionHandler.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">Executor1</span></code>
                  </p>
                </td>
<td>
                  <p>
                    The type of the executor used when the handler has no associated
                    executor. An instance of this type must be provided upon construction.
                    The implementation will maintain an executor work guard and a
                    copy of this instance.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">Allocator</span></code>
                  </p>
                </td>
<td>
                  <p>
                    The allocator type to use if the handler does not have an associated
                    allocator. If this parameter is omitted, then <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code> will be used. If the specified
                    allocator is not default constructible, an instance of the type
                    must be provided upon construction.
                  </p>
                </td>
</tr>
</tbody>
</table></div>
<h6>
<a name="beast.using_io.ref.boost__beast__async_op_base.h7"></a>
          <span class="phrase"><a name="beast.using_io.ref.boost__beast__async_op_base.see_also"></a></span><a class="link" href="boost__beast__async_op_base.html#beast.using_io.ref.boost__beast__async_op_base.see_also">See Also</a>
        </h6>
<p>
          <a class="link" href="../../../"><code class="computeroutput"><span class="identifier">stable_async_op_base</span></code></a>
        </p>
<p>
          Convenience header <code class="literal">&lt;<a href="../../../../../../../boost/beast/core.hpp" target="_top">boost/beast/core.hpp</a>&gt;</code>
        </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016, 2017 Vinnie Falco<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="boost__beast__async_connect/overload4.html"><img src="../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../ref.html"><img src="../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="boost__beast__async_op_base/allocator_type.html"><img src="../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
