<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Writing Composed Operations</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Beast">
<link rel="up" href="../using_i_o.html" title="Using I/O">
<link rel="prev" href="files.html" title="Files">
<link rel="next" href="example_detect_ssl.html" title="Example: Detect SSL">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="Beast Logo" width="1330" height="80" src="../../images/beast.png"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="files.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../using_i_o.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="example_detect_ssl.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="beast.using_i_o.writing_composed_operations"></a><a class="link" href="writing_composed_operations.html" title="Writing Composed Operations">Writing
      Composed Operations</a>
</h3></div></div></div>
<p>
        Asynchronous operations are started by calling a free function or member
        function known as an asynchronous <span class="emphasis"><em><a href="http://www.boost.org/doc/html/boost_asio/reference/asynchronous_operations.html" target="_top">initiating
        function</a></em></span>. This function accepts parameters specific to
        the operation as well as a "completion token." The token is either
        a completion handler, or a type defining how the caller is informed of the
        asynchronous operation result. <a href="http://www.boost.org/doc/html/boost_asio.html" target="_top">Boost.Asio</a>
        comes with the special tokens <a href="http://www.boost.org/doc/html/boost_asio/reference/use_future_t.html" target="_top"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">use_future</span></code></a> and <a href="http://www.boost.org/doc/html/boost_asio/reference/yield_context.html" target="_top"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">yield_context</span></code></a> for using futures
        and coroutines respectively. This system of customizing the return value
        and method of completion notification is known as the <span class="emphasis"><em>Extensible
        Asynchronous Model</em></span> described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3747.pdf" target="_top"><span class="bold"><strong>N3747</strong></span></a>, and a built in to <a href="http://cplusplus.github.io/networking-ts/draft.pdf" target="_top"><span class="bold"><strong>N4588</strong></span></a>. Here is an example of an initiating
        function which reads a line from the stream and echoes it back. This function
        is developed further in the next section:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">class</span> <span class="identifier">AsyncStream</span><span class="special">,</span>
    <span class="keyword">class</span> <span class="identifier">CompletionToken</span><span class="special">&gt;</span>
<span class="keyword">auto</span>
<span class="identifier">async_echo</span><span class="special">(</span><span class="identifier">AsyncStream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="identifier">CompletionToken</span><span class="special">&amp;&amp;</span> <span class="identifier">token</span><span class="special">)</span>
</pre>
<p>
        Authors using Beast can reuse the library's primitives to create their own
        initiating functions for performing a series of other, intermediate asynchronous
        operations before invoking a final completion handler. The set of intermediate
        actions produced by an initiating function is known as a <a href="http://blog.think-async.com/2009/08/composed-operations-coroutines-and-code.html" target="_top"><span class="emphasis"><em>composed
        operation</em></span></a>. To ensure full interoperability and well-defined
        behavior, <a href="http://www.boost.org/doc/html/boost_asio.html" target="_top">Boost.Asio</a>
        imposes requirements on the implementation of composed operations. These
        classes and functions make it easier to develop initiating functions and
        their composed operations:
      </p>
<div class="table">
<a name="beast.using_i_o.writing_composed_operations.asynchronous_helpers"></a><p class="title"><b>Table&#160;9.&#160;Asynchronous Helpers</b></p>
<div class="table-contents"><table class="table" summary="Asynchronous Helpers">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Name
                </p>
              </th>
<th>
                <p>
                  Description
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <a class="link" href="../ref/beast__async_completion.html" title="async_completion"><code class="computeroutput"><span class="identifier">async_completion</span></code></a>
                </p>
              </td>
<td>
                <p>
                  This class aggregates the completion handler customization point
                  and the asynchronous initiation function return value customization
                  point into a single object which exposes the appropriate output
                  types for the given input types, and also contains boilerplate
                  that is necessary to implement an initiation function using the
                  Extensible Model.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../ref/beast__async_return_type.html" title="async_return_type"><code class="computeroutput"><span class="identifier">async_return_type</span></code></a>
                </p>
              </td>
<td>
                <p>
                  This template alias determines the return value of an asynchronous
                  initiation function given the completion token and signature. It
                  is used by asynchronous initiation functions to meet the requirements
                  of the Extensible Asynchronous Model.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../ref/beast__bind_handler.html" title="bind_handler"><code class="computeroutput"><span class="identifier">bind_handler</span></code></a>
                </p>
              </td>
<td>
                <p>
                  This function returns a new, nullary completion handler which when
                  invoked with no arguments invokes the original completion handler
                  with a list of bound arguments. The invocation is made from the
                  same implicit or explicit strand as that which would be used to
                  invoke the original handler. This is accomplished by using the
                  correct overload of <code class="computeroutput"><span class="identifier">asio_handler_invoke</span></code>
                  associated with the original completion handler.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../ref/beast__handler_alloc.html" title="handler_alloc"><code class="computeroutput"><span class="identifier">handler_alloc</span></code></a>
                </p>
              </td>
<td>
                <p>
                  This class meets the requirements of <span class="bold"><strong>Allocator</strong></span>,
                  and uses any custom memory allocation and deallocation hooks associated
                  with a given handler. It is useful for when a composed operation
                  requires temporary dynamic allocations to achieve its result. Memory
                  allocated using this allocator must be freed before the final completion
                  handler is invoked.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../ref/beast__handler_ptr.html" title="handler_ptr"><code class="computeroutput"><span class="identifier">handler_ptr</span></code></a>
                </p>
              </td>
<td>
                <p>
                  This is a smart pointer container used to manage the internal state
                  of a composed operation. It is useful when the state is non trivial.
                  For example when the state has non-copyable or expensive to copy
                  types. The container takes ownership of the final completion handler,
                  and provides boilerplate to invoke the final handler in a way that
                  also deletes the internal state. The internal state is allocated
                  using the final completion handler's associated allocator, benefiting
                  from all handler memory management optimizations transparently.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="../ref/beast__handler_type.html" title="handler_type"><code class="computeroutput"><span class="identifier">handler_type</span></code></a>
                </p>
              </td>
<td>
                <p>
                  This template alias converts a completion token and signature to
                  the correct completion handler type. It is used in the implementation
                  of asynchronous initiation functions to meet the requirements of
                  the Extensible Asynchronous Model.
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="beast.using_i_o.writing_composed_operations.echo"></a><a class="link" href="writing_composed_operations.html#beast.using_i_o.writing_composed_operations.echo" title="Echo">Echo</a>
</h4></div></div></div>
<p>
          This example develops an initiating function called <span class="bold"><strong>echo</strong></span>.
          The operation will read up to the first newline on a stream, and then write
          the same line including the newline back on the stream. The implementation
          performs both reading and writing, and has a non-trivially-copyable state.
          First we define the input parameters and results, then declare our initiation
          function. For our echo operation the only inputs are the stream and the
          completion token. The output is the error code which is usually included
          in all completion handler signatures.
        </p>
<pre class="programlisting"><span class="comment">/** Asynchronously read a line and echo it back.

    This function is used to asynchronously read a line ending
    in a carriage-return ("CR") from the stream, and then write
    it back. The function call always returns immediately. The
    asynchronous operation will continue until one of the
    following conditions is true:

    @li A line was read in and sent back on the stream

    @li An error occurs.

    This operation is implemented in terms of one or more calls to
    the stream's `async_read_some` and `async_write_some` functions,
    and is known as a &lt;em&gt;composed operation&lt;/em&gt;. The program must
    ensure that the stream performs no other operations until this
    operation completes. The implementation may read additional octets
    that lie past the end of the line being read. These octets are
    silently discarded.

    @param The stream to operate on. The type must meet the
    requirements of @b AsyncReadStream and @AsyncWriteStream

    @param token The completion token to use. If this is a
    completion handler, copies will be made as required.
    The equivalent signature of the handler must be:
    @code
    void handler(
        error_code ec       // result of operation
    );
    @endcode
    Regardless of whether the asynchronous operation completes
    immediately or not, the handler will not be invoked from within
    this function. Invocation of the handler will be performed in a
    manner equivalent to using `boost::asio::io_service::post`.
*/</span>
<span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">class</span> <span class="identifier">AsyncStream</span><span class="special">,</span>
    <span class="keyword">class</span> <span class="identifier">CompletionToken</span><span class="special">&gt;</span>
<span class="identifier">beast</span><span class="special">::</span><span class="identifier">async_return_type</span><span class="special">&lt;</span>       <a class="co" name="beast.using_i_o.writing_composed_operations.echo.c0" href="writing_composed_operations.html#beast.using_i_o.writing_composed_operations.echo.c1"><img src="../../images/callouts/1.png" alt="1" border="0"></a>
    <span class="identifier">CompletionToken</span><span class="special">,</span>
    <span class="keyword">void</span><span class="special">(</span><span class="identifier">beast</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">)&gt;</span>    <a class="co" name="beast.using_i_o.writing_composed_operations.echo.c2" href="writing_composed_operations.html#beast.using_i_o.writing_composed_operations.echo.c3"><img src="../../images/callouts/2.png" alt="2" border="0"></a>
<span class="identifier">async_echo</span><span class="special">(</span>
    <span class="identifier">AsyncStream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span>
    <span class="identifier">CompletionToken</span><span class="special">&amp;&amp;</span> <span class="identifier">token</span><span class="special">);</span>
</pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><p><a name="beast.using_i_o.writing_composed_operations.echo.c1"></a><a href="#beast.using_i_o.writing_composed_operations.echo.c0"><img src="../../images/callouts/1.png" alt="1" border="0"></a> </p></td>
<td valign="top" align="left"><p>
              The <a class="link" href="../ref/beast__async_return_type.html" title="async_return_type"><code class="computeroutput"><span class="identifier">async_return_type</span></code></a> customizes
              the return value based on the completion token
            </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="beast.using_i_o.writing_composed_operations.echo.c3"></a><a href="#beast.using_i_o.writing_composed_operations.echo.c2"><img src="../../images/callouts/2.png" alt="2" border="0"></a> </p></td>
<td valign="top" align="left"><p>
              This is the signature for the completion handler
            </p></td>
</tr>
</table></div>
<p>
          Now that we have a declaration, we will define the body of the function.
          We want to achieve the following goals: perform static type checking on
          the input parameters, set up the return value as per <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3747.pdf" target="_top"><span class="bold"><strong>N3747</strong></span></a>, and launch the composed operation
          by constructing the object and invoking it.
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Handler</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">echo_op</span><span class="special">;</span>

<span class="comment">// Read a line and echo it back</span>
<span class="comment">//</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">CompletionToken</span><span class="special">&gt;</span>
<span class="identifier">beast</span><span class="special">::</span><span class="identifier">async_return_type</span><span class="special">&lt;</span><span class="identifier">CompletionToken</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">beast</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">)&gt;</span>
<span class="identifier">async_echo</span><span class="special">(</span><span class="identifier">AsyncStream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="identifier">CompletionToken</span><span class="special">&amp;&amp;</span> <span class="identifier">token</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Make sure stream meets the requirements. We use static_assert</span>
    <span class="comment">// to cause a friendly message instead of an error novel.</span>
    <span class="comment">//</span>
    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">beast</span><span class="special">::</span><span class="identifier">is_async_stream</span><span class="special">&lt;</span><span class="identifier">AsyncStream</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span>
        <span class="string">"AsyncStream requirements not met"</span><span class="special">);</span>

    <span class="comment">// This helper manages some of the handler's lifetime and</span>
    <span class="comment">// uses the result and handler specializations associated with</span>
    <span class="comment">// the completion token to help customize the return value.</span>
    <span class="comment">//</span>
    <span class="identifier">beast</span><span class="special">::</span><span class="identifier">async_completion</span><span class="special">&lt;</span><span class="identifier">CompletionToken</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">beast</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">)&gt;</span> <span class="identifier">init</span><span class="special">{</span><span class="identifier">token</span><span class="special">};</span>

    <span class="comment">// Create the composed operation and launch it. This is a constructor</span>
    <span class="comment">// call followed by invocation of operator(). We use handler_type</span>
    <span class="comment">// to convert the completion token into the correct handler type,</span>
    <span class="comment">// allowing user-defined specializations of the async_result template</span>
    <span class="comment">// to be used.</span>
    <span class="comment">//</span>
    <span class="identifier">echo_op</span><span class="special">&lt;</span><span class="identifier">AsyncStream</span><span class="special">,</span> <span class="identifier">beast</span><span class="special">::</span><span class="identifier">handler_type</span><span class="special">&lt;</span><span class="identifier">CompletionToken</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">beast</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">)&gt;&gt;{</span>
        <span class="identifier">stream</span><span class="special">,</span> <span class="identifier">init</span><span class="special">.</span><span class="identifier">completion_handler</span><span class="special">}(</span><span class="identifier">beast</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">{},</span> <span class="number">0</span><span class="special">);</span>

    <span class="comment">// This hook lets the caller see a return value when appropriate.</span>
    <span class="comment">// For example this might return std::future&lt;error_code&gt; if</span>
    <span class="comment">// CompletionToken is boost::asio::use_future, or this might</span>
    <span class="comment">// return an error code if CompletionToken specifies a coroutine.</span>
    <span class="comment">//</span>
    <span class="keyword">return</span> <span class="identifier">init</span><span class="special">.</span><span class="identifier">result</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
          The initiating function contains a few relatively simple parts. There is
          the customization of the return value type, static type checking, building
          the return value type using the helper, and creating and launching the
          composed operation object. The <span class="bold"><strong><code class="computeroutput"><span class="identifier">echo_op</span></code></strong></span>
          object does most of the work here, and has a somewhat non-trivial structure.
          This structure is necessary to meet the stringent requirements of composed
          operations (described in more detail in the <a href="http://www.boost.org/doc/html/boost_asio.html" target="_top">Boost.Asio</a>
          documentation). We will touch on these requirements without explaining
          them in depth.
        </p>
<p>
          Here is the boilerplate present in all composed operations written in this
          style:
        </p>
<pre class="programlisting"><span class="comment">// This composed operation reads a line of input and echoes it back.</span>
<span class="comment">//</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Handler</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">echo_op</span>
<span class="special">{</span>
    <span class="comment">// This holds all of the state information required by the operation.</span>
    <span class="keyword">struct</span> <span class="identifier">state</span>
    <span class="special">{</span>
        <span class="comment">// The stream to read and write to</span>
        <span class="identifier">AsyncStream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">;</span>

        <span class="comment">// Indicates what step in the operation's state machine</span>
        <span class="comment">// to perform next, starting from zero.</span>
        <span class="keyword">int</span> <span class="identifier">step</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

        <span class="comment">// The buffer used to hold the input and output data.</span>
        <span class="comment">//</span>
        <span class="comment">// We use a custom allocator for performance, this allows</span>
        <span class="comment">// the implementation of the io_service to make efficient</span>
        <span class="comment">// re-use of memory allocated by composed operations during</span>
        <span class="comment">// a continuation.</span>
        <span class="comment">//</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">basic_streambuf</span><span class="special">&lt;</span><span class="identifier">beast</span><span class="special">::</span><span class="identifier">handler_alloc</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">,</span> <span class="identifier">Handler</span><span class="special">&gt;&gt;</span> <span class="identifier">buffer</span><span class="special">;</span>

        <span class="comment">// handler_ptr requires that the first parameter to the</span>
        <span class="comment">// contained object constructor is a reference to the</span>
        <span class="comment">// managed final completion handler.</span>
        <span class="comment">//</span>
        <span class="keyword">explicit</span> <span class="identifier">state</span><span class="special">(</span><span class="identifier">Handler</span><span class="special">&amp;</span> <span class="identifier">handler</span><span class="special">,</span> <span class="identifier">AsyncStream</span><span class="special">&amp;</span> <span class="identifier">stream_</span><span class="special">)</span>
            <span class="special">:</span> <span class="identifier">stream</span><span class="special">(</span><span class="identifier">stream_</span><span class="special">)</span>
            <span class="special">,</span> <span class="identifier">buffer</span><span class="special">((</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">&gt;::</span><span class="identifier">max</span><span class="special">)(),</span>
                <span class="identifier">beast</span><span class="special">::</span><span class="identifier">handler_alloc</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">,</span> <span class="identifier">Handler</span><span class="special">&gt;{</span><span class="identifier">handler</span><span class="special">})</span>
        <span class="special">{</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="comment">// The operation's data is kept in a cheap-to-copy smart</span>
    <span class="comment">// pointer container called `handler_ptr`. This efficiently</span>
    <span class="comment">// satisfies the CopyConstructible requirements of completion</span>
    <span class="comment">// handlers.</span>
    <span class="comment">//</span>
    <span class="comment">// `handler_ptr` uses these memory allocation hooks associated</span>
    <span class="comment">// with the final completion handler, in order to allocate the</span>
    <span class="comment">// storage for `state`:</span>
    <span class="comment">//</span>
    <span class="comment">//      asio_handler_allocate</span>
    <span class="comment">//      asio_handler_deallocate</span>
    <span class="comment">//</span>
    <span class="identifier">beast</span><span class="special">::</span><span class="identifier">handler_ptr</span><span class="special">&lt;</span><span class="identifier">state</span><span class="special">,</span> <span class="identifier">Handler</span><span class="special">&gt;</span> <span class="identifier">p_</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Boost.Asio requires that handlers are CopyConstructible.</span>
    <span class="comment">// In some cases, it takes advantage of handlers that are</span>
    <span class="comment">// MoveConstructible. This operation supports both.</span>
    <span class="comment">//</span>
    <span class="identifier">echo_op</span><span class="special">(</span><span class="identifier">echo_op</span><span class="special">&amp;&amp;)</span> <span class="special">=</span> <span class="keyword">default</span><span class="special">;</span>
    <span class="identifier">echo_op</span><span class="special">(</span><span class="identifier">echo_op</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">default</span><span class="special">;</span>

    <span class="comment">// The constructor simply creates our state variables in</span>
    <span class="comment">// the smart pointer container.</span>
    <span class="comment">//</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">DeducedHandler</span><span class="special">,</span> <span class="keyword">class</span><span class="special">...</span> <span class="identifier">Args</span><span class="special">&gt;</span>
    <span class="identifier">echo_op</span><span class="special">(</span><span class="identifier">AsyncStream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="identifier">DeducedHandler</span><span class="special">&amp;&amp;</span> <span class="identifier">handler</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">p_</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">DeducedHandler</span><span class="special">&gt;(</span><span class="identifier">handler</span><span class="special">),</span> <span class="identifier">stream</span><span class="special">)</span>
    <span class="special">{</span>
    <span class="special">}</span>

    <span class="comment">// The entry point for this handler. This will get called</span>
    <span class="comment">// as our intermediate operations complete. Definition below.</span>
    <span class="comment">//</span>
    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">beast</span><span class="special">::</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bytes_transferred</span><span class="special">);</span>

    <span class="comment">// The next four functions are required for our class</span>
    <span class="comment">// to meet the requirements for composed operations.</span>
    <span class="comment">// Definitions and exposition will follow.</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream_</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Handler_</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Function</span><span class="special">&gt;</span>
    <span class="keyword">friend</span> <span class="keyword">void</span>  <span class="identifier">asio_handler_invoke</span><span class="special">(</span>
        <span class="identifier">Function</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">echo_op</span><span class="special">&lt;</span><span class="identifier">AsyncStream_</span><span class="special">,</span> <span class="identifier">Handler_</span><span class="special">&gt;*</span> <span class="identifier">op</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream_</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Handler_</span><span class="special">&gt;</span>
    <span class="keyword">friend</span> <span class="keyword">void</span><span class="special">*</span> <span class="identifier">asio_handler_allocate</span><span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">,</span> <span class="identifier">echo_op</span><span class="special">&lt;</span><span class="identifier">AsyncStream_</span><span class="special">,</span> <span class="identifier">Handler_</span><span class="special">&gt;*</span> <span class="identifier">op</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream_</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Handler_</span><span class="special">&gt;</span>
    <span class="keyword">friend</span> <span class="keyword">void</span>  <span class="identifier">asio_handler_deallocate</span><span class="special">(</span>
        <span class="keyword">void</span><span class="special">*</span> <span class="identifier">p</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">,</span> <span class="identifier">echo_op</span><span class="special">&lt;</span><span class="identifier">AsyncStream_</span><span class="special">,</span> <span class="identifier">Handler_</span><span class="special">&gt;*</span> <span class="identifier">op</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream_</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Handler_</span><span class="special">&gt;</span>
    <span class="keyword">friend</span> <span class="keyword">bool</span>  <span class="identifier">asio_handler_is_continuation</span><span class="special">(</span>
        <span class="identifier">echo_op</span><span class="special">&lt;</span><span class="identifier">AsyncStream_</span><span class="special">,</span> <span class="identifier">Handler_</span><span class="special">&gt;*</span> <span class="identifier">op</span><span class="special">);</span>
<span class="special">};</span>
</pre>
<p>
          Next is to implement the function call operator. Our strategy is to make
          our composed object meet the requirements of a completion handler by being
          copyable (also movable), and by providing the function call operator with
          the correct signature. Rather than using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span></code>
          or <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span></code>, which destroys the type information
          and therefore breaks the allocation and invocation hooks, we will simply
          pass <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span></code> as
          the completion handler parameter for any operations that we initiate. For
          the move to work correctly, care must be taken to ensure that no access
          to data members are made after the move takes place. Here is the implementation
          of the function call operator for this echo operation:
        </p>
<pre class="programlisting"><span class="comment">// echo_op is callable with the signature void(error_code, bytes_transferred),</span>
<span class="comment">// allowing `*this` to be used as both a ReadHandler and a WriteHandler.</span>
<span class="comment">//</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Handler</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">echo_op</span><span class="special">&lt;</span><span class="identifier">AsyncStream</span><span class="special">,</span> <span class="identifier">Handler</span><span class="special">&gt;::</span>
<span class="keyword">operator</span><span class="special">()(</span><span class="identifier">beast</span><span class="special">::</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bytes_transferred</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Store a reference to our state. The address of the state won't</span>
    <span class="comment">// change, and this solves the problem where dereferencing the</span>
    <span class="comment">// data member is undefined after a move.</span>
    <span class="keyword">auto</span><span class="special">&amp;</span> <span class="identifier">p</span> <span class="special">=</span> <span class="special">*</span><span class="identifier">p_</span><span class="special">;</span>

    <span class="comment">// Now perform the next step in the state machine</span>
    <span class="keyword">switch</span><span class="special">(</span><span class="identifier">ec</span> <span class="special">?</span> <span class="number">2</span> <span class="special">:</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">step</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="comment">// initial entry</span>
        <span class="keyword">case</span> <span class="number">0</span><span class="special">:</span>
            <span class="comment">// read up to the first newline</span>
            <span class="identifier">p</span><span class="special">.</span><span class="identifier">step</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span>
            <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">async_read_until</span><span class="special">(</span><span class="identifier">p</span><span class="special">.</span><span class="identifier">stream</span><span class="special">,</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">buffer</span><span class="special">,</span> <span class="string">"\r"</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span>

        <span class="keyword">case</span> <span class="number">1</span><span class="special">:</span>
            <span class="comment">// write everything back</span>
            <span class="identifier">p</span><span class="special">.</span><span class="identifier">step</span> <span class="special">=</span> <span class="number">2</span><span class="special">;</span>
            <span class="comment">// async_read_until could have read past the newline,</span>
            <span class="comment">// use buffer_prefix to make sure we only send one line</span>
            <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">async_write</span><span class="special">(</span><span class="identifier">p</span><span class="special">.</span><span class="identifier">stream</span><span class="special">,</span>
                <span class="identifier">beast</span><span class="special">::</span><span class="identifier">buffer_prefix</span><span class="special">(</span><span class="identifier">bytes_transferred</span><span class="special">,</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">buffer</span><span class="special">.</span><span class="identifier">data</span><span class="special">()),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span>

        <span class="keyword">case</span> <span class="number">2</span><span class="special">:</span>
            <span class="identifier">p</span><span class="special">.</span><span class="identifier">buffer</span><span class="special">.</span><span class="identifier">consume</span><span class="special">(</span><span class="identifier">bytes_transferred</span><span class="special">);</span>
            <span class="keyword">break</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Invoke the final handler. The implementation of `handler_ptr`</span>
    <span class="comment">// will deallocate the storage for the state before the handler</span>
    <span class="comment">// is invoked. This is necessary to provide the</span>
    <span class="comment">// destroy-before-invocation guarantee on handler memory</span>
    <span class="comment">// customizations.</span>
    <span class="comment">//</span>
    <span class="comment">// If we wanted to pass any arguments to the handler which come</span>
    <span class="comment">// from the `state`, they would have to be moved to the stack</span>
    <span class="comment">// first or else undefined behavior results.</span>
    <span class="comment">//</span>
    <span class="identifier">p_</span><span class="special">.</span><span class="identifier">invoke</span><span class="special">(</span><span class="identifier">ec</span><span class="special">);</span>
    <span class="keyword">return</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          This is the most important element of writing a composed operation, and
          the part which is often neglected or implemented incorrectly. It is the
          declaration and definition of the "handler hooks". There are
          four hooks:
        </p>
<div class="table">
<a name="beast.using_i_o.writing_composed_operations.echo.handler_hooks"></a><p class="title"><b>Table&#160;10.&#160;Handler Hooks</b></p>
<div class="table-contents"><table class="table" summary="Handler Hooks">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Name
                  </p>
                </th>
<th>
                  <p>
                    Description
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    <a href="http://www.boost.org/doc/html/boost_asio/reference/asio_handler_invoke.html" target="_top"><code class="computeroutput"><span class="identifier">asio_handler_invoke</span></code></a>
                  </p>
                </td>
<td>
                  <p>
                    Default invoke function for handlers. This hooking function ensures
                    that the invoked method used for the final handler is accessible
                    at each intermediate step.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <a href="http://www.boost.org/doc/html/boost_asio/reference/asio_handler_allocate.html" target="_top"><code class="computeroutput"><span class="identifier">asio_handler_allocate</span></code></a>
                  </p>
                </td>
<td>
                  <p>
                    Default allocation function for handlers. Implement <code class="computeroutput"><span class="identifier">asio_handler_allocate</span></code> and
                    <code class="computeroutput"><span class="identifier">asio_handler_deallocate</span></code>
                    for your own handlers to provide custom allocation for temporary
                    objects.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <a href="http://www.boost.org/doc/html/boost_asio/reference/asio_handler_deallocate.html" target="_top"><code class="computeroutput"><span class="identifier">asio_handler_deallocate</span></code></a>
                  </p>
                </td>
<td>
                  <p>
                    Default deallocation function for handlers. Implement <code class="computeroutput"><span class="identifier">asio_handler_allocate</span></code> and
                    <code class="computeroutput"><span class="identifier">asio_handler_deallocate</span></code>
                    for your own handlers to provide custom allocation for temporary
                    objects.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <a href="http://www.boost.org/doc/html/boost_asio/reference/asio_handler_is_continuation.html" target="_top"><code class="computeroutput"><span class="identifier">asio_handler_is_continuation</span></code></a>
                  </p>
                </td>
<td>
                  <p>
                    Default continuation function for handlers. Implement <code class="computeroutput"><span class="identifier">asio_handler_is_continuation</span></code>
                    for your own handlers to indicate when a handler represents a
                    continuation.
                  </p>
                </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
          Our composed operation stores the final handler and performs its own intermediate
          asynchronous operations. To ensure that I/O objects, in this case the stream,
          are accessed safely it is important to use the same method to invoke intermediate
          handlers as that used to invoke the final handler. Similarly, for the memory
          allocation hooks our composed operation should use the same hooks as those
          used by the final handler. And finally for the <code class="computeroutput"><span class="identifier">asio_is_continuation</span></code>
          hook, we want to return <code class="computeroutput"><span class="keyword">true</span></code>
          for any intermediate asynchronous operations we perform after the first
          one, since those represent continuations. For the first asynchronous operation
          we perform, the hook should return <code class="computeroutput"><span class="keyword">true</span></code>
          only if the final handler also represents a continuation. Our implementation
          of the hooks will forward the call to the corresponding overloads of the
          final handler:
        </p>
<pre class="programlisting"><span class="comment">// Handler hook forwarding. These free functions invoke the hooks</span>
<span class="comment">// associated with the final completion handler. In effect, they</span>
<span class="comment">// make the Asio implementation treat our composed operation the</span>
<span class="comment">// same way it would treat the final completion handler for the</span>
<span class="comment">// purpose of memory allocation and invocation.</span>
<span class="comment">//</span>
<span class="comment">// Our implementation just passes the call through to the hook</span>
<span class="comment">// associated with the final handler. The "using" statements are</span>
<span class="comment">// structured to permit argument dependent lookup. Always use</span>
<span class="comment">// `std::addressof` or its equivalent to pass the pointer to the</span>
<span class="comment">// handler, otherwise an unwanted overload of `operator&amp;` may be</span>
<span class="comment">// called instead.</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Handler</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Function</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">asio_handler_invoke</span><span class="special">(</span>
    <span class="identifier">Function</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">echo_op</span><span class="special">&lt;</span><span class="identifier">AsyncStream</span><span class="special">,</span> <span class="identifier">Handler</span><span class="special">&gt;*</span> <span class="identifier">op</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">asio_handler_invoke</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">asio_handler_invoke</span><span class="special">(</span><span class="identifier">f</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">addressof</span><span class="special">(</span><span class="identifier">op</span><span class="special">-&gt;</span><span class="identifier">p_</span><span class="special">.</span><span class="identifier">handler</span><span class="special">()));</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Handler</span><span class="special">&gt;</span>
<span class="keyword">void</span><span class="special">*</span> <span class="identifier">asio_handler_allocate</span><span class="special">(</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">,</span> <span class="identifier">echo_op</span><span class="special">&lt;</span><span class="identifier">AsyncStream</span><span class="special">,</span> <span class="identifier">Handler</span><span class="special">&gt;*</span> <span class="identifier">op</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">asio_handler_allocate</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">asio_handler_allocate</span><span class="special">(</span><span class="identifier">size</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">addressof</span><span class="special">(</span><span class="identifier">op</span><span class="special">-&gt;</span><span class="identifier">p_</span><span class="special">.</span><span class="identifier">handler</span><span class="special">()));</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Handler</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">asio_handler_deallocate</span><span class="special">(</span>
    <span class="keyword">void</span><span class="special">*</span> <span class="identifier">p</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">,</span> <span class="identifier">echo_op</span><span class="special">&lt;</span><span class="identifier">AsyncStream</span><span class="special">,</span> <span class="identifier">Handler</span><span class="special">&gt;*</span> <span class="identifier">op</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">asio_handler_deallocate</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">asio_handler_deallocate</span><span class="special">(</span><span class="identifier">p</span><span class="special">,</span> <span class="identifier">size</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">addressof</span><span class="special">(</span><span class="identifier">op</span><span class="special">-&gt;</span><span class="identifier">p_</span><span class="special">.</span><span class="identifier">handler</span><span class="special">()));</span>
<span class="special">}</span>

<span class="comment">// Determines if the next asynchronous operation represents a</span>
<span class="comment">// continuation of the asynchronous flow of control associated</span>
<span class="comment">// with the final handler. If we are past step one, it means</span>
<span class="comment">// we have performed an asynchronous operation therefore any</span>
<span class="comment">// subsequent operation would represent a continuation.</span>
<span class="comment">// Otherwise, we propagate the handler's associated value of</span>
<span class="comment">// is_continuation. Getting this right means the implementation</span>
<span class="comment">// may schedule the invokation of the invoked functions more</span>
<span class="comment">// efficiently.</span>
<span class="comment">//</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncStream</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Handler</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">asio_handler_is_continuation</span><span class="special">(</span><span class="identifier">echo_op</span><span class="special">&lt;</span><span class="identifier">AsyncStream</span><span class="special">,</span> <span class="identifier">Handler</span><span class="special">&gt;*</span> <span class="identifier">op</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// This next call is structured to permit argument</span>
    <span class="comment">// dependent lookup to take effect.</span>
    <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">asio_handler_is_continuation</span><span class="special">;</span>

    <span class="comment">// Always use std::addressof to pass the pointer to the handler,</span>
    <span class="comment">// otherwise an unwanted overload of operator&amp; may be called instead.</span>
    <span class="keyword">return</span> <span class="identifier">op</span><span class="special">-&gt;</span><span class="identifier">p_</span><span class="special">-&gt;</span><span class="identifier">step</span> <span class="special">&gt;</span> <span class="number">1</span> <span class="special">||</span>
        <span class="identifier">asio_handler_is_continuation</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">addressof</span><span class="special">(</span><span class="identifier">op</span><span class="special">-&gt;</span><span class="identifier">p_</span><span class="special">.</span><span class="identifier">handler</span><span class="special">()));</span>
<span class="special">}</span>
</pre>
<p>
          There are some common mistakes that should be avoided when writing composed
          operations:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              Type erasing the final handler. This will cause undefined behavior.
            </li>
<li class="listitem">
              Not using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">addressof</span></code> to get the address of the
              handler.
            </li>
<li class="listitem">
              Forgetting to include a return statement after calling an initiating
              function.
            </li>
<li class="listitem">
              Calling a synchronous function by accident. In general composed operations
              should not block for long periods of time, since this ties up a thread
              running on the <a href="http://www.boost.org/doc/html/boost_asio/reference/io_service.html" target="_top"><code class="computeroutput"><span class="identifier">io_service</span></code></a>.
            </li>
<li class="listitem">
              Forgetting to overload <code class="computeroutput"><span class="identifier">asio_handler_invoke</span></code>
              for the composed operation. This will cause undefined behavior if someone
              calls the initiating function with a strand-wrapped function object,
              and there is more than thread running on the <code class="computeroutput"><span class="identifier">io_service</span></code>.
            </li>
<li class="listitem">
              For operations which complete immediately (i.e. without calling an
              intermediate initiating function), forgetting to use <code class="computeroutput"><span class="identifier">io_service</span><span class="special">::</span><span class="identifier">post</span></code> to invoke the final handler.
              This breaks the following initiating function guarantee: <span class="emphasis"><em>Regardless
              of whether the asynchronous operation completes immediately or not,
              the handler will not be invoked from within this function. Invocation
              of the handler will be performed in a manner equivalent to using <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">io_service</span><span class="special">::</span><span class="identifier">post</span></code></em></span>. The function <a class="link" href="../ref/beast__bind_handler.html" title="bind_handler"><code class="computeroutput"><span class="identifier">bind_handler</span></code></a>
              is provided for this purpose.
            </li>
</ul></div>
<p>
          A complete, runnable version of this example may be found in the examples
          directory.
        </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013-2017 Vinnie Falco<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="files.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../using_i_o.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="example_detect_ssl.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
